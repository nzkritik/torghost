#!/usr/bin/env python3
"""
TorGhost - Clean and Working Version

This script controls system-level configuration to route traffic through Tor.
It must be run as root for actions that modify system services, networking,
and firewall rules.

Detailed comments have been added throughout to explain the purpose of each
section and the reasoning behind key operations.
"""

# --- Standard library imports ------------------------------------------------
# os, sys: file paths, exit, effective UID checks
# subprocess: run system commands (systemctl, iptables, curl, id)
# time: used for timestamps in logging
# signal: capture Ctrl-C / SIGINT to perform a clean shutdown
# shutil: file operations such as copying and moving files (resolv.conf backup)
# socket: used to check if Tor ports are open
import os
import sys
import subprocess
import time
import signal
import shutil
import socket  # added for port checks

# --- Third-party dependency check -------------------------------------------
# 'stem' is required to control the Tor process via its control port and to
# request new circuits (NEWNYM). Rather than attempting to auto-install here,
# provide a clear message to the operator if it's missing and exit with guidance.
try:
    from stem import Signal
    from stem.control import Controller
except Exception:
    # Informative guidance for installing the dependency
    print("Required Python package 'stem' is not installed.")
    print("On Arch: sudo pacman -S python-stem")
    print("Or with pip: pip install stem")
    sys.exit(1)


# --- Terminal color helper class --------------------------------------------
# bcolors provides a small, local set of escape sequences to color terminal
# output. Used to make status and error messages easier to spot.
class bcolors:
    BLUE = '\033[94m'
    GREEN = '\033[92m'
    RED = '\033[31m'
    YELLOW = '\033[93m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'

# User feedback helper functions (timestamped, colored)
def info(msg):
    """Informational status message."""
    print(f"{t()} {bcolors.BLUE}{msg}{bcolors.ENDC}")

def success(msg):
    """Success message."""
    print(f"{t()} {bcolors.GREEN}{msg}{bcolors.ENDC}")

def warn(msg):
    """Non-fatal warning."""
    print(f"{t()} {bcolors.YELLOW}{msg}{bcolors.ENDC}")

def error(msg, fatal=False):
    """Error message; if fatal True, exit after printing."""
    print(f"{t()} {bcolors.RED}{msg}{bcolors.ENDC}")
    if fatal:
        sys.exit(1)


# --- Utility functions -------------------------------------------------------
def t():
    """
    Return a compact timestamp string for human-readable logs.

    Example: [14:22:09]
    """
    return "[" + time.strftime('%H:%M:%S') + "]"


def sigint_handler(signum, frame):
    """
    Signal handler for SIGINT (Ctrl-C). Ensures a polite shutdown message
    and exits cleanly by delegating to shutdown().
    """
    print('\nUser interrupt! Shutting down')
    shutdown()


def shutdown():
    """
    Perform any necessary cleanup (if added later) and exit the program.
    Currently prints a timestamped shutdown message and exits.
    """
    print(f"\n{t()} Shutting down torghost")
    sys.exit()


def logo():
    """
    Clear the terminal and print the ASCII banner + version info.
    Kept in a function so it can be reused before interactive usage/help text.
    """
    os.system("clear")
    print(f"{bcolors.RED}{bcolors.BOLD}")
    print(r"""
                                                     
▄▄▄▄▄▄▄▄▄           ▄▄▄▄▄▄▄  ▄▄                      
▀▀▀███▀▀▀          ███▀▀▀▀▀  ██                 ██   
   ███ ▄███▄ ████▄ ███       ████▄ ▄███▄ ▄█▀▀▀ ▀██▀▀ 
   ███ ██ ██ ██ ▀▀ ███  ███▀ ██ ██ ██ ██ ▀███▄  ██   
   ███ ▀███▀ ██    ▀██████▀  ██ ██ ▀███▀ ▄▄▄█▀  ██   
                                                            
    v3.0 - rewritten by nzkritik for Arch Linux
    """)
    print(f"{bcolors.ENDC}")


def usage():
    """
    Print usage instructions and exit. Shows the logo and a basic help message.
    """
    logo()
    print("""
    USAGE:
        sudo torghost start   (start torghost)
        sudo torghost stop    (stop torghost) 
        sudo torghost switch  (switch IP)
        torghost status       (show status)
    """)
    sys.exit()


def get_ip():
    """
    Query an external service (api.ipify.org) to fetch the public IP.

    Strategy:
    1) Quick local curl attempt (short timeouts).
    2) If that fails or times out, attempt via Tor SOCKS5 proxy at 127.0.0.1:9050,
       retrying a few times to allow circuits to bootstrap.
    3) Return "Unknown" and warn if all attempts fail.

    This avoids long curl hangs (exit status 28) and works when Tor is active
    by sending the request over the Tor SOCKS proxy.
    """
    # Ensure curl exists first
    if shutil.which('curl') is None:
        warn("curl not found — cannot query external IP (install curl to enable).")
        return "Unknown"

    # 1) Try direct curl with short timeouts (may fail if DNS/Network routed via Tor)
    direct_attempts = 2
    for attempt in range(1, direct_attempts + 1):
        info(f"Querying external IP (direct) attempt {attempt}/{direct_attempts}...")
        try:
            res = subprocess.run(
                ['curl', '-s', '--connect-timeout', '5', '--max-time', '10', 'https://api.ipify.org'],
                capture_output=True, text=True
            )
            if res.returncode == 0 and res.stdout.strip():
                ip = res.stdout.strip()
                success(f"External IP detected (direct): {ip}")
                return ip
            else:
                warn(f"Direct curl attempt {attempt} failed (exit {res.returncode}).")
        except Exception as e:
            warn(f"Direct curl attempt {attempt} raised exception: {e}")
        time.sleep(1)

    # 2) Fall back to using Tor SOCKS5 proxy (expects Tor's SocksPort on 127.0.0.1:9050)
    socks_attempts = 5
    for attempt in range(1, socks_attempts + 1):
        info(f"Querying external IP via Tor SOCKS5 attempt {attempt}/{socks_attempts}...")
        try:
            res = subprocess.run(
                ['curl', '-s', '--socks5-hostname', '127.0.0.1:9050', '--connect-timeout', '5', '--max-time', '15', 'https://api.ipify.org'],
                capture_output=True, text=True
            )
            if res.returncode == 0 and res.stdout.strip():
                ip = res.stdout.strip()
                success(f"External IP detected via Tor: {ip}")
                return ip
            else:
                warn(f"Tor SOCKS curl attempt {attempt} failed (exit {res.returncode}). Retrying...")
        except Exception as e:
            warn(f"Tor SOCKS curl attempt {attempt} raised exception: {e}")
        time.sleep(2)

    # All attempts failed
    warn("Unable to determine external IP after multiple attempts; returning 'Unknown'.")
    return "Unknown"


# New helper: wait for a TCP port to be reachable on host
def wait_for_port(host, port, timeout=60, interval=1):
    """
    Wait until a TCP port is accepting connections.
    Returns True if the port is reachable within timeout, False otherwise.
    """
    deadline = time.time() + timeout
    while time.time() < deadline:
        try:
            with socket.create_connection((host, port), timeout=2):
                return True
        except Exception:
            time.sleep(interval)
    return False


# --- Core operational functions ----------------------------------------------
def start_torghost():
    """
    Start TorGhost by:
    1. Appending a Tor configuration block (torrc) if not already present.
    2. Backing up and modifying /etc/resolv.conf to point DNS to localhost.
    3. Starting the Tor systemd service.
    4. Determining the 'tor' user UID for firewall exclusions.
    5. Applying iptables and ip6tables rules to route DNS and TCP traffic
       through Tor while excluding local/private networks and the tor user.
    """

    # --- torrc configuration ------------------------------------------------
    # We write a small configuration block to ensure Tor listens on the
    # ports we expect (TransPort 9040, DNSPort 53, ControlPort 9051) and
    # that VirtualAddrNetwork/AutomapHostsOnResolve are enabled.
    torrc_path = '/etc/tor/torrc'
    torrc_marker = '## TorGhost Configuration'
    torrc_content = f"""
{torrc_marker}
VirtualAddrNetwork 10.0.0.0/10
AutomapHostsOnResolve 1
TransPort 9040
DNSPort 53
ControlPort 9051
"""

    info("Appending Tor configuration to /etc/tor/torrc (if missing)...")
    try:
        # Read existing torrc and append the marker block only if it's missing
        with open(torrc_path, 'r') as f:
            existing = f.read()

        if torrc_marker not in existing:
            with open(torrc_path, 'a') as f:
                f.write(torrc_content)
            success("Tor configuration appended to /etc/tor/torrc.")
        else:
            info("Tor configuration marker already present; skipping append.")
    except IOError as e:
        error(f"Error modifying torrc: {e}", fatal=True)

    # --- Start Tor service and wait for it to be ready --------------------
    info("Starting tor service (systemctl start tor)...")
    try:
        subprocess.run(['systemctl', 'start', 'tor'], check=True,
                       stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        success("Tor service start requested.")
        subprocess.run(['systemctl', 'status', 'tor'], check=True)
    except subprocess.CalledProcessError:
        error("Failed to start Tor service.", fatal=True)

    # Wait for Tor control port to be available
    info("Waiting for Tor control port (127.0.0.1:9051) to become available (timeout 60s)...")
    if not wait_for_port('127.0.0.1', 9051, timeout=60):
        error("Tor control port 9051 did not become available in time. Aborting.", fatal=True)
    success("Tor control port is reachable.")

    # Wait for TransPort (9040) to be listening (required for transparent proxying)
    info("Waiting for Tor TransPort (127.0.0.1:9040) to become available (timeout 30s)...")
    if not wait_for_port('127.0.0.1', 9040, timeout=30):
        warn("Tor TransPort 9040 did not appear to be listening yet. Transparent proxying may fail.")
    else:
        success("Tor TransPort is reachable.")

    # --- DNS configuration / backup (moved until Tor is up) ----------------
    # Define resolv paths used for backup/restore and replacement.
    resolv = '/etc/resolv.conf'
    resolv_backup = '/etc/resolv.conf.bak-torghost'
    resolv_backup_link = '/etc/resolv.conf.bak-torghost-link'

    info("Preparing DNS configuration (resolv.conf) — backing up and pointing to Tor DNSPort...")
    try:
        if os.path.islink(resolv):
            orig_target = os.readlink(resolv)
            info(f"/etc/resolv.conf is a symlink to {orig_target}; recording and replacing with a plain file.")
            with open(resolv_backup_link, 'w') as f:
                f.write(orig_target)
            os.remove(resolv)
        else:
            if not os.path.exists(resolv_backup):
                shutil.copy(resolv, resolv_backup)
                info(f"Backed up /etc/resolv.conf to {resolv_backup}")
            else:
                info("Existing resolv.conf backup found; will not overwrite.")

        # Write a plain resolv.conf pointing to the local Tor DNSPort
        with open(resolv, 'w') as f:
            f.write("nameserver 127.0.0.1\n")
        success("Wrote /etc/resolv.conf -> nameserver 127.0.0.1")
    except IOError as e:
        error(f"Error configuring DNS: {e}", fatal=True)

    # --- Determine Tor user's UID -----------------------------------------
    info("Determining 'tor' user UID for firewall exemptions...")
    try:
        tor_uid = subprocess.run(['id', '-u', 'tor'],
                                 capture_output=True, text=True, check=True).stdout.strip()
        info(f"Using tor UID: {tor_uid}")
    except subprocess.CalledProcessError:
        error("Failed to get Tor UID.", fatal=True)

    # --- Prepare iptables (IPv4) script -----------------------------------
    # Build the iptables script as a heredoc string and then execute in bash.
    # Updated to:
    # - Exclude full RFC1918 ranges (10/8, 172.16/12, 192.168/16), carrier-grade NAT (100.64/10),
    #   link-local (169.254/16) and multicast (224/4) from redirection.
    # - Exempt the tor user's traffic to avoid loops.
    # - Redirect UDP/TCP port 53 (DNS) to Tor DNSPort and redirect TCP SYN to TransPort.
    # - In filter table accept established/related, tor user, and local networks, then REJECT all else.
    iptables_script = f"""
iptables -F
iptables -t nat -F

# Don't redirect traffic generated by the tor user (avoid loops)
iptables -t nat -A OUTPUT -m owner --uid-owner {tor_uid} -j RETURN

# Exclude local / private / link-local / multicast destinations from redirection
iptables -t nat -A OUTPUT -d 127.0.0.0/8 -j RETURN
iptables -t nat -A OUTPUT -d 10.0.0.0/8 -j RETURN
iptables -t nat -A OUTPUT -d 172.16.0.0/12 -j RETURN
iptables -t nat -A OUTPUT -d 192.168.0.0/16 -j RETURN
iptables -t nat -A OUTPUT -d 100.64.0.0/10 -j RETURN
iptables -t nat -A OUTPUT -d 169.254.0.0/16 -j RETURN
iptables -t nat -A OUTPUT -d 224.0.0.0/4 -j RETURN

# Redirect DNS (UDP & TCP) to Tor DNSPort
iptables -t nat -A OUTPUT -p udp --dport 53 -j REDIRECT --to-ports 53
iptables -t nat -A OUTPUT -p tcp --dport 53 -j REDIRECT --to-ports 53

# Redirect outgoing TCP connections to Tor TransPort
iptables -t nat -A OUTPUT -p tcp --syn -j REDIRECT --to-ports 9040

# Filter rules: allow established and exempted traffic, block the rest
iptables -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT

# Allow local/network management and loopback destinations
iptables -A OUTPUT -d 127.0.0.0/8 -j ACCEPT
iptables -A OUTPUT -d 10.0.0.0/8 -j ACCEPT
iptables -A OUTPUT -d 172.16.0.0/12 -j ACCEPT
iptables -A OUTPUT -d 192.168.0.0/16 -j ACCEPT
iptables -A OUTPUT -d 100.64.0.0/10 -j ACCEPT
iptables -A OUTPUT -d 169.254.0.0/16 -j ACCEPT

# Allow traffic from the tor user
iptables -A OUTPUT -m owner --uid-owner {tor_uid} -j ACCEPT

# Reject everything else (makes sure non-exempt IPv4 traffic must go via Tor)
iptables -A OUTPUT -j REJECT
"""

    # --- Prepare ip6tables (IPv6) script ----------------------------------
    # Many systems may not have IPv6 configured; this script attempts to apply
    # IPv6 equivalents. Failure to apply is non-fatal but emits a warning.
    # For troubleshooting IPv6 is currently disabled — comment out the script.
    # ip6tables_script = f"""
    # ip6tables -F
    # ip6tables -t nat -F
    # ip6tables -t nat -A OUTPUT -m owner --uid-owner {tor_uid} -j RETURN
    # ip6tables -t nat -A OUTPUT -p udp --dport 53 -j REDIRECT --to-ports 53
    # ip6tables -t nat -A OUTPUT -p tcp --dport 53 -j REDIRECT --to-ports 53
    # ip6tables -t nat -A OUTPUT -d ::1/128 -j RETURN
    # ip6tables -t nat -A OUTPUT -d fc00::/7 -j RETURN
    # ip6tables -t nat -A OUTPUT -p tcp --syn -j REDIRECT --to-ports 9040
    # ip6tables -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
    # ip6tables -A OUTPUT -d ::1/128 -j ACCEPT
    # ip6tables -A OUTPUT -d fc00::/7 -j ACCEPT
    # ip6tables -A OUTPUT -m owner --uid-owner {tor_uid} -j ACCEPT
    # ip6tables -A OUTPUT -j REJECT
    # """

    # --- Apply iptables rules ---------------------------------------------
    info("Applying IPv4 iptables rules to route traffic through Tor...")
    try:
        subprocess.run(['bash', '-c', iptables_script], check=True,
                       stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        success("IPv4 iptables rules applied.")
    except subprocess.CalledProcessError:
        error("Failed to apply IPv4 iptables rules.", fatal=True)

    # IPv6 handling disabled for troubleshooting.
    #info("IPv6 ip6tables application is currently disabled for troubleshooting")

    # Small delay to allow Tor circuits to bootstrap and for NAT to stabilize
    #info("Waiting a few seconds for Tor to bootstrap circuits...")
    #time.sleep(5)

    # --- Final status messages --------------------------------------------
    success(f"TorGhost started. Current IP: {get_ip()}")
    info("Note: All DNS (IPv4) and TCP traffic routed through Tor.")
    info("Run 'sudo torghost stop' to revert all changes.")

def stop_torghost():
    """
    Revert changes made by start_torghost:
    1. Flush IPv4 and IPv6 firewall rules (reset policies to ACCEPT).
    2. Stop the Tor service.
    3. Remove the TorGhost block from torrc.
    4. Restore backed-up /etc/resolv.conf if present.
    """

    # --- Flush IPv4 iptables ----------------------------------------------
    info("Flushing IPv4 iptables and restoring default ACCEPT policies...")
    try:
        subprocess.run(['bash', '-c', """
iptables -P INPUT ACCEPT
iptables -P FORWARD ACCEPT
iptables -P OUTPUT ACCEPT
iptables -t nat -F
iptables -t mangle -F
iptables -F
iptables -X
"""], check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        success("IPv4 firewall flushed.")
    except subprocess.CalledProcessError:
        warn("Failed to flush IPv4 iptables; manual intervention may be required.")

    # --- Flush IPv6 ip6tables --------------------------------------------
    # IPv6 flushing is disabled while troubleshooting to avoid interfering
    # with current diagnostics. Uncomment the block below to re-enable.
    # info("Flushing IPv6 ip6tables and restoring default ACCEPT policies...")
    # try:
    #     subprocess.run(['bash', '-c', """
    # ip6tables -P INPUT ACCEPT
    # ip6tables -P FORWARD ACCEPT
    # ip6tables -P OUTPUT ACCEPT
    # ip6tables -t nat -F
    # ip6tables -t mangle -F
    # ip6tables -F
    # ip6tables -X
    # """], check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    #     success("IPv6 firewall flushed.")
    # except subprocess.CalledProcessError:
    #     warn("Failed to flush IPv6 iptables; manual intervention may be required.")
    info("IPv6 ip6tables flush is currently disabled for troubleshooting.")

    # --- Stop Tor service -------------------------------------------------
    info("Stopping Tor service (systemctl stop tor)...")
    try:
        subprocess.run(['systemctl', 'stop', 'tor'], check=True,
                       stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        success("Tor service stopped.")
    except subprocess.CalledProcessError:
        warn("Failed to stop Tor service; it may already be stopped or not installed.")

    # --- Clean up torrc ---------------------------------------------------
    # Ensure torrc path/marker are defined (use module constants)
    torrc_path = TORRC_PATH
    torrc_marker = TORRC_MARKER

    info("Cleaning up tor configuration in /etc/tor/torrc...")
    try:
        with open(torrc_path, 'r') as f:
            lines = f.readlines()

        in_block = False
        cleaned_lines = []
        for line in lines:
            if torrc_marker in line:
                in_block = True
                continue
            if in_block and line.strip() == '':
                in_block = False
                continue
            if not in_block:
                cleaned_lines.append(line)

        with open(torrc_path, 'w') as f:
            f.writelines(cleaned_lines)
        success("Removed TorGhost configuration block from torrc.")
    except IOError as e:
        warn(f"Failed to clean torrc: {e}")

    # --- Restore network resolver ----------------------------------------
    # Define resolv paths used for backup/restore and restoration steps.
    resolv = '/etc/resolv.conf'
    resolv_backup = '/etc/resolv.conf.bak-torghost'
    resolv_backup_link = '/etc/resolv.conf.bak-torghost-link'

    info("Restoring original /etc/resolv.conf (or symlink) if backup exists...")
    if os.path.exists(resolv_backup_link):
        try:
            with open(resolv_backup_link, 'r') as f:
                orig_target = f.read().strip()
            if os.path.exists(resolv):
                try:
                    os.remove(resolv)
                except Exception:
                    pass
            os.symlink(orig_target, resolv)
            os.remove(resolv_backup_link)
            success("Restored original resolv.conf symlink.")
        except IOError as e:
            warn(f"Failed to restore symlinked resolv.conf: {e}")
    elif os.path.exists(resolv_backup):
        try:
            shutil.move(resolv_backup, resolv)
            success("Restored backup /etc/resolv.conf.")
        except IOError as e:
            warn(f"Failed to restore resolv.conf: {e}")
    else:
        warn("No resolv.conf backup found. DNS may need manual restoration.")

    # --- Final status messages --------------------------------------------
    success(f"TorGhost stopped. Current IP: {get_ip()}")

def switch_tor():
    """
    Ask the Tor control port for a new circuit (NEWNYM), effectively switching
    the exit node and changing the apparent public IP. Wait a short time for
    the circuit to be established and then report the new IP.
    """
    with Controller.from_port(port=9051) as controller:
        controller.authenticate()
        controller.signal(Signal.NEWNYM)
    # Allow time for the new circuit to be used
    time.sleep(5)
    print(f"{t()} CURRENT IP: {bcolors.GREEN}{get_ip()}{bcolors.ENDC}")


def show_status():
    """
    Show basic status: whether the tor service is active and the current IP.
    This is a non-root operation (only reads state).
    """
    ip = get_ip()
    tor_status = subprocess.run(['systemctl', 'is-active', 'tor'],
                                capture_output=True, text=True).stdout.strip()
    print(f"Tor Status: {tor_status}")
    print(f"Current IP: {ip}")


# --- Constants -------------------------------------------------------------
# Centralize tor configuration path and marker so all functions can reference them
TORRC_PATH = '/etc/tor/torrc'
TORRC_MARKER = '## TorGhost Configuration'

# --- Main execution flow ----------------------------------------------------
# Install a SIGINT handler to allow graceful exit with Ctrl-C.
signal.signal(signal.SIGINT, sigint_handler)

# Basic CLI parsing. Require a single subcommand.
if len(sys.argv) < 2:
    usage()
    show_status()

command = sys.argv[1].lower()

# For operations that modify system state, ensure running as root.
if command in ['start', 'stop', 'switch']:
    if os.geteuid() != 0:
        print(f"{bcolors.RED}{bcolors.BOLD}You must be root to run this command.{bcolors.ENDC}")
        sys.exit(1)

# Dispatch subcommands to their handlers.
if command == "start":
    logo()
    start_torghost()
elif command == "stop":
    logo()
    stop_torghost()
elif command == "switch":
    switch_tor()
elif command == "status":
    show_status()
else:
    usage()
