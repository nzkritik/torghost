#!/usr/bin/env python3
"""
TorGhost - Fixed Version for Arch Linux
This script controls system-level configuration to route traffic through Tor.
It must be run as root for actions that modify system services, networking,
and firewall rules.
KEY IMPROVEMENTS FROM ORIGINAL:
- Fixed systemd-resolved conflicts with proper masking and symlink handling
- Added comprehensive Tor bootstrap verification
- Fixed NAT loop issues with explicit exemptions and PREROUTING rule handling
- Added proper checkpoint/restore mechanism for system recovery
- Added comprehensive error handling and diagnostics
- Added explicit exemptions for Tor's own traffic to avoid loops
- Added proper Docker and systemd-resolved management with restoration
"""
# --- Standard library imports ------------------------------------------------
import os
import sys
import subprocess
import time
import signal
import shutil
import socket
import threading
import re
import json
import logging
# --- Third-party dependency check -------------------------------------------
try:
    from stem import Signal
    from stem.control import Controller
except Exception:
    print("Required Python package 'stem' is not installed.")
    print("On Arch: sudo pacman -S python-stem")
    print("Or with pip: pip install stem")
    sys.exit(1)
# --- Terminal color helper class --------------------------------------------
class bcolors:
    BLUE = '\033[94m'
    GREEN = '\033[92m'
    RED = '\033[31m'
    YELLOW = '\033[93m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
# --- Development warning banner (shown on every run) -----------------------
DEV_WARNING = r"""
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!                              CRITICAL WARNING                               !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!  THIS SCRIPT MODIFIES SYSTEM NETWORKING, DNS, AND FIREWALL RULES.          !!
!!                                                                              !!
!!  It will:                                                                    !!
!!  - Stop and mask systemd-resolved                                           !!
!!  - Modify /etc/resolv.conf                                                   !!
!!  - Change iptables/ip6tables rules                                           !!
!!  - Stop Docker temporarily if running                                       !!
!!  - Route ALL traffic through Tor                                             !!
!!                                                                              !!
!!  WARNING:                                                                    !!
!!  - Your internet WILL NOT WORK if Tor fails to start properly.              !!
!!  - Some applications may break due to the network changes.                 !!
!!  - A system crash during execution may require manual recovery.            !!
!!                                                                              !!
!!  RECOMMENDED:                                                                !!
!!  - Take a system snapshot before running                                    !!
!!  - Have physical/console access available in case networking breaks         !!
!!  - Run in a VM or non-critical system first                                 !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
"""
def print_dev_warning():
    """Print the development warning banner to the terminal and pause briefly."""
    try:
        print(f"{bcolors.RED}{bcolors.BOLD}{DEV_WARNING}{bcolors.ENDC}")
        sys.stdout.flush()
        time.sleep(5)
    except Exception:
        print(DEV_WARNING)
        sys.stdout.flush()
        time.sleep(5)
# User feedback helper functions (timestamped, colored)
def info(msg):
    """Informational status message."""
    print(f"{t()} {bcolors.BLUE}{msg}{bcolors.ENDC}")
    logging.info(msg)
def success(msg):
    """Success message."""
    print(f"{t()} {bcolors.GREEN}{msg}{bcolors.ENDC}")
    logging.info(msg)
def warn(msg):
    """Non-fatal warning."""
    print(f"{t()} {bcolors.YELLOW}{msg}{bcolors.ENDC}")
    logging.warning(msg)
def error(msg, fatal=False):
    """Error message; if fatal True, exit after printing."""
    print(f"{t()} {bcolors.RED}{msg}{bcolors.ENDC}")
    logging.error(msg)
    if fatal:
        # Try to restore system state before exiting
        try:
            restore_system_state()
        except Exception as e:
            warn(f"Failed to restore system state during error handling: {e}")
        sys.exit(1)
# --- Utility functions -------------------------------------------------------
def t():
    """
    Return a compact timestamp string for human-readable logs.
    Example: [14:22:09]
    """
    return "[" + time.strftime('%H:%M:%S') + "]"
def sigint_handler(signum, frame):
    """
    Signal handler for SIGINT (Ctrl-C). Ensures a polite shutdown message
    and exits cleanly by delegating to shutdown().
    """
    print('User interrupt! Shutting down and restoring system state')
    restore_system_state()
    sys.exit(0)
def shutdown():
    """
    Perform any necessary cleanup and exit the program.
    """
    print(f"{t()} Shutting down torghost")
    restore_system_state()
    sys.exit(0)
def logo():
    """
    Clear the terminal and print the ASCII banner + version info.
    """
    os.system("clear")
    print(f"{bcolors.RED}{bcolors.BOLD}")
    print(r"""
▄▄▄▄▄▄▄▄▄           ▄▄▄▄▄▄▄  ▄▄                      
▀▀▀███▀▀▀          ███▀▀▀▀▀  ██                 ██   
   ███ ▄███▄ ████▄ ███       ████▄ ▄███▄ ▄█▀▀▀ ▀██▀▀ 
   ███ ██ ██ ██ ▀▀ ███  ███▀ ██ ██ ██ ██ ▀███▄  ██   
   ███ ▀███▀ ██    ▀██████▀  ██ ██ ▀███▀ ▄▄▄█▀  ██   
    v3.1 - fixed version for Arch Linux
    """)
    print(f"{bcolors.ENDC}")
def usage():
    """
    Print usage instructions and exit.
    """
    logo()
    print("""
    USAGE:
        sudo torghost start   (start torghost - routes ALL traffic through Tor)
        sudo torghost stop    (stop torghost - restore normal networking)
        sudo torghost switch  (switch to new Tor circuit/IP)
        torghost status       (show current status)
        sudo torghost check-leak [interval_seconds]
            (run continuous DNS leak monitoring; default interval 10s)
        sudo torghost diag    (run comprehensive diagnostics)

    WARNING: Using TorGhost will route ALL your network traffic through Tor,
    which may be significantly slower than normal browsing and will hide your
    real IP address from websites.
    """)
    sys.exit()
def get_ip():
    """
    Query an external service to fetch the public IP.
    Strategy:
    - Try Tor SOCKS first if available
    - Fall back to direct connection
    """
    # Ensure curl exists
    if shutil.which('curl') is None:
        warn("curl not found — cannot query external IP (install curl to enable).")
        return "Unknown"
    # If SocksPort is available use it first
    socks_first = wait_for_port('127.0.0.1', 9050, timeout=1)
    def curl_request(args):
        try:
            res = subprocess.run(args, capture_output=True, text=True, timeout=15)
            if res.returncode == 0 and res.stdout.strip():
                return res.stdout.strip()
        except Exception as e:
            warn(f"curl raised exception: {e}")
        return None
    # Try via Tor SOCKS first if available
    if socks_first:
        for attempt in range(1, 4):
            info(f"Querying external IP via Tor SOCKS5 attempt {attempt}/3...")
            ip = curl_request(['curl', '-s', '--socks5-hostname', '127.0.0.1:9050', '--connect-timeout', '5', '--max-time', '10', 'https://api.ipify.org'])
            if ip:
                success(f"External IP detected via Tor: {ip}")
                return ip
            time.sleep(1)
    # Fall back to direct connection
    for attempt in range(1, 3):
        info(f"Querying external IP (direct) attempt {attempt}/2...")
        ip = curl_request(['curl', '-s', '--connect-timeout', '5', '--max-time', '10', 'https://api.ipify.org'])
        if ip:
            success(f"External IP detected (direct): {ip}")
            return ip
        time.sleep(1)
    warn("Unable to determine external IP after multiple attempts")
    return "Unknown"

# Helper: wait for a TCP port to be reachable
def wait_for_port(host, port, timeout=60, interval=1):
    """
    Wait until a TCP port is accepting connections.
    Returns True if the port is reachable within timeout, False otherwise.
    """
    deadline = time.time() + timeout
    while time.time() < deadline:
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(2)
            result = sock.connect_ex((host, int(port)))
            sock.close()
            if result == 0:
                return True
        except Exception:
            pass
        time.sleep(interval)
    return False

# IPv6 handling helpers
def disable_ipv6():
    """
    Save current IPv6 sysctl values and disable IPv6 system-wide.
    """
    info("Disabling IPv6 system-wide for duration of TorGhost...")
    keys = ['net.ipv6.conf.all.disable_ipv6', 'net.ipv6.conf.default.disable_ipv6']
    prev = {}
    for key in keys:
        try:
            res = subprocess.run(['sysctl', '-n', key], capture_output=True, text=True, timeout=10)
            if res.returncode == 0:
                prev[key] = res.stdout.strip()
            else:
                prev[key] = '0'
        except Exception as e:
            prev[key] = '0'
            warn(f"Could not read {key}: {e}")
    # Save previous values
    try:
        with open(IPV6_BACKUP_FILE, 'w') as f:
            json.dump(prev, f)
    except Exception as e:
        warn(f"Could not write IPv6 backup file: {e}")
    # Disable ipv6
    for key in keys:
        try:
            subprocess.run(['sysctl', '-w', f'{key}=1'], check=True, timeout=10)
        except Exception as e:
            warn(f"Failed to set {key}=1: {e}")
    success("IPv6 disabled (sysctl values set).")
def restore_ipv6():
    """
    Restore IPv6 sysctl values from backup file.
    """
    if not os.path.exists(IPV6_BACKUP_FILE):
        info("No IPv6 backup file found; skipping IPv6 restore.")
        return
    try:
        with open(IPV6_BACKUP_FILE, 'r') as f:
            prev = json.load(f)
        for key, val in prev.items():
            try:
                subprocess.run(['sysctl', '-w', f'{key}={val}'], check=True, timeout=10)
            except Exception as e:
                warn(f"Failed to restore {key}={val}: {e}")
        os.remove(IPV6_BACKUP_FILE)
        success("IPv6 sysctl values restored from backup.")
    except Exception as e:
        warn(f"Failed to restore IPv6 settings: {e}")

# --- Constants -------------------------------------------------------------
TORRC_PATH = '/etc/tor/torrc'
TORRC_MARKER = '## TorGhost Configuration'
IPV6_BACKUP_FILE = '/etc/tor/torghost-ipv6-backup'
RESOLVED_BACKUP_FILE = '/etc/resolv.conf.bak-torghost'
RESOLVED_STOP_MARKER = '/run/torghost-stopped-systemd-resolved'
DOCKER_STOP_MARKER = '/run/torghost-stopped-docker'
TORRC_BACKUP_PATH = f"{TORRC_PATH}.bak-torghost"
CHECKPOINT_DIR = '/run/torghost'
LATEST_CHECKPOINT = os.path.join(CHECKPOINT_DIR, 'latest.json')

# Tor configuration block
TORCONTENT = f"""
{TORRC_MARKER}
Nickname TorGhostNode
VirtualAddrNetwork 10.192.0.0/10
AutomapHostsOnResolve 1
TransPort 127.0.0.1:9040
DNSPort 127.0.0.1:5353
ControlPort 127.0.0.1:9051
CookieAuthentication 1
CookieAuthFile /run/tor/control.authcookie
RunAsDaemon 0
"""

# iptables rules template
IPTABLESSCRIPT = """
# Clear existing rules
iptables -F
iptables -t nat -F
iptables -t mangle -F
iptables -t raw -F
# Print current state for diagnostics
iptables -t nat -L OUTPUT -n --line-numbers
# NAT rules
# Prevent redirecting packets destined to local addresses
iptables -t nat -I OUTPUT 1 -m addrtype --dst-type LOCAL -j RETURN || true
# Exempt system and Tor user traffic
iptables -t nat -I OUTPUT 2 -m owner --uid-owner 0 -j RETURN
iptables -t nat -I OUTPUT 3 -m owner --uid-owner {tor_uid} -j RETURN
# Prevent Tor's own traffic from being redirected to itself
iptables -t nat -I OUTPUT 4 -p tcp --dport 9040 -j RETURN
iptables -t nat -I OUTPUT 5 -p tcp --dport 9050 -j RETURN
iptables -t nat -I OUTPUT 6 -p tcp --dport 9051 -j RETURN
iptables -t nat -I OUTPUT 7 -p udp --dport 5353 -j RETURN
iptables -t nat -I OUTPUT 8 -p udp --dport 53 -m owner --uid-owner {tor_uid} -j RETURN || true
# Don't redirect traffic to private networks
iptables -t nat -A OUTPUT -d 127.0.0.0/8 -j RETURN
iptables -t nat -A OUTPUT -d 10.0.0.0/8 -j RETURN
iptables -t nat -A OUTPUT -d 172.16.0.0/12 -j RETURN
iptables -t nat -A OUTPUT -d 192.168.0.0/16 -j RETURN
iptables -t nat -A OUTPUT -d 100.64.0.0/10 -j RETURN
iptables -t nat -A OUTPUT -d 169.254.0.0/16 -j RETURN
iptables -t nat -A OUTPUT -d 224.0.0.0/4 -j RETURN
# Redirect DNS and TCP traffic
iptables -t nat -A OUTPUT -p udp --dport 53 -m owner ! --uid-owner {tor_uid} -j REDIRECT --to-ports {dns_port}
iptables -t nat -A OUTPUT -p tcp --dport 53 -m owner ! --uid-owner {tor_uid} -j REDIRECT --to-ports {dns_port}
iptables -t nat -A OUTPUT -p tcp --syn -m owner ! --uid-owner {tor_uid} -j REDIRECT --to-ports 9040
# Filter rules
iptables -P FORWARD ACCEPT
iptables -P INPUT ACCEPT
iptables -P OUTPUT ACCEPT
iptables -F
iptables -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
iptables -A OUTPUT -d 127.0.0.0/8 -j ACCEPT
iptables -A OUTPUT -d 10.0.0.0/8 -j ACCEPT
iptables -A OUTPUT -d 172.16.0.0/12 -j ACCEPT
iptables -A OUTPUT -d 192.168.0.0/16 -j ACCEPT
iptables -A OUTPUT -d 100.64.0.0/10 -j ACCEPT
iptables -A OUTPUT -d 169.254.0.0/16 -j ACCEPT
iptables -A OUTPUT -m owner --uid-owner {tor_uid} -j ACCEPT
iptables -A OUTPUT -m owner --uid-owner 0 -j ACCEPT
iptables -A OUTPUT -j REJECT
"""

def is_docker_active():
    """Check if Docker service is active."""
    try:
        result = subprocess.run(['systemctl', 'is-active', 'docker'],
                               capture_output=True, text=True, timeout=10)
        return result.stdout.strip() == 'active'
    except Exception:
        return False

def stop_docker_and_wait(timeout=15):
    """Stop Docker service and handle DOCKER PREROUTING rules."""
    try:
        if not is_docker_active():
            info("Docker not active; skipping stop.")
            return False
        info("Creating checkpoint before stopping Docker")
        create_checkpoint('docker_prestop', {'note': 'stopping docker to avoid NAT interference'})
        info("Stopping Docker to avoid Docker/ADDRTYPE NAT interference...")
        subprocess.run(['systemctl', 'stop', 'docker'], check=True, timeout=10)
        # Wait for Docker to fully stop
        deadline = time.time() + timeout
        while time.time() < deadline:
            if not is_docker_active():
                try:
                    with open(DOCKER_STOP_MARKER, 'w') as f:
                        f.write(f"stopped at {time.time()}")
                    create_checkpoint('docker_stopped', {'time': time.time()})
                    success("Docker stopped (marker written).")
                    # Backup and clean nat table
                    cleanup_docker_nat_rules()
                    return True
                except Exception as e:
                    warn(f"Could not write Docker stop marker: {e}")
            time.sleep(0.5)
        warn("Timed out waiting for Docker to stop, continuing anyway")
        return True
    except Exception as e:
        warn(f"Failed to stop Docker: {e}")
        return False

def cleanup_docker_nat_rules():
    """Backup and remove problematic Docker PREROUTING rules that can cause NAT loops."""
    try:
        # Check for problematic PREROUTING rules
        p = subprocess.run(['bash', '-c',
            "iptables -t nat -S PREROUTING | grep -E 'ADDRTYPE|DOCKER' || true"],
            capture_output=True, text=True, timeout=15)
        if p.stdout.strip():
            info("Found Docker PREROUTING rules that may cause NAT loops")
            ts = int(time.time())
            backup = f"/run/torghost-nat-backup-{ts}.rules"
            try:
                subprocess.run(['bash', '-c', f'iptables-save -t nat > {backup}'],
                             check=True, timeout=15)
                create_checkpoint('nat_backup', {'path': backup, 'time': ts})
                info(f"Backed up nat table to {backup}")
            except Exception as e:
                warn(f"Could not backup nat table: {e}")
            # Try to remove problematic rules
            rules_to_remove = [
                "iptables -t nat -D PREROUTING -m addrtype --dst-type LOCAL -j DOCKER",
                "iptables -t nat -D PREROUTING -j DOCKER"
            ]
            for rule in rules_to_remove:
                try:
                    r = subprocess.run(['bash', '-c', rule],
                                     capture_output=True, text=True, timeout=10)
                    if r.returncode == 0:
                        success(f"Removed problematic PREROUTING rule: {rule}")
                    else:
                        debug(f"Could not remove rule '{rule}': {r.stderr.strip()}")
                except Exception as e:
                    debug(f"Error removing rule: {e}")
    except Exception as e:
        warn(f"Error while cleaning up Docker nat rules: {e}")

def restore_docker_if_stopped():
    """Start Docker if it was stopped by torghost."""
    try:
        if not os.path.exists(DOCKER_STOP_MARKER):
            return
        if not shutil.which('systemctl'):
            warn("systemctl not available; cannot restore Docker automatically.")
            return
        info("Restoring Docker service that was stopped by torghost...")
        subprocess.run(['systemctl', 'start', 'docker'], check=True, timeout=15)
        try:
            os.remove(DOCKER_STOP_MARKER)
        except Exception:
            pass
        success("Docker service restored")
    except Exception as e:
        warn(f"Failed to restore Docker: {e}")

def stop_systemd_resolved():
    """Stop and mask systemd-resolved to free up port 53."""
    try:
        info("Stopping and masking systemd-resolved to free port 53...")
        # Create checkpoint before making changes
        create_checkpoint('resolved_prestop', {'note': 'stopping systemd-resolved'})
        # Stop and mask the service
        subprocess.run(['systemctl', 'stop', 'systemd-resolved'], check=False, timeout=10)
        subprocess.run(['systemctl', 'mask', 'systemd-resolved'], check=False, timeout=10)
        subprocess.run(['systemctl', 'stop', 'systemd-resolved.socket'], check=False, timeout=10)
        # Create marker file
        with open(RESOLVED_STOP_MARKER, 'w') as f:
            f.write(f"stopped at {time.time()}")
        create_checkpoint('resolved_stopped', {'time': time.time()})
        success("systemd-resolved stopped and masked")
        return True
    except Exception as e:
        warn(f"Failed to stop systemd-resolved: {e}")
        return False

def restore_systemd_resolved():
    """Restore systemd-resolved if it was stopped by torghost."""
    try:
        if not os.path.exists(RESOLVED_STOP_MARKER):
            return False
        info("Restoring systemd-resolved service...")
        # Unmask and start the service
        subprocess.run(['systemctl', 'unmask', 'systemd-resolved'], check=False, timeout=10)
        subprocess.run(['systemctl', 'start', 'systemd-resolved'], check=False, timeout=10)
        # Remove marker file
        try:
            os.remove(RESOLVED_STOP_MARKER)
        except Exception:
            pass
        success("systemd-resolved service restored")
        return True
    except Exception as e:
        warn(f"Failed to restore systemd-resolved: {e}")
        return False

def backup_resolv_conf():
    """Backup the current resolv.conf file or symlink."""
    try:
        resolv_path = '/etc/resolv.conf'
        if os.path.islink(resolv_path):
            # Handle symlink
            link_target = os.readlink(resolv_path)
            info(f"/etc/resolv.conf is a symlink to {link_target}")
            # Save the symlink target
            with open(f"{RESOLVED_BACKUP_FILE}.link", 'w') as f:
                f.write(link_target)
            # Remove the symlink
            os.remove(resolv_path)
            info("Removed symlink to /etc/resolv.conf")
        elif os.path.exists(resolv_path):
            # Regular file backup
            if not os.path.exists(RESOLVED_BACKUP_FILE):
                shutil.copy(resolv_path, RESOLVED_BACKUP_FILE)
                info(f"Backed up /etc/resolv.conf to {RESOLVED_BACKUP_FILE}")
            else:
                info("Existing resolv.conf backup found; will not overwrite")
        return True
    except Exception as e:
        warn(f"Failed to backup resolv.conf: {e}")
        return False

def restore_resolv_conf():
    """Restore the original resolv.conf file or symlink."""
    try:
        resolv_path = '/etc/resolv.conf'
        link_backup = f"{RESOLVED_BACKUP_FILE}.link"
        # If symlink backup exists, restore the symlink
        if os.path.exists(link_backup):
            with open(link_backup, 'r') as f:
                link_target = f.read().strip()
            # Remove current resolv.conf if it exists
            if os.path.exists(resolv_path):
                os.remove(resolv_path)
            # Create the symlink
            os.symlink(link_target, resolv_path)
            info(f"Restored symlink to {link_target}")
            # Clean up backup files
            try:
                os.remove(link_backup)
                if os.path.exists(RESOLVED_BACKUP_FILE):
                    os.remove(RESOLVED_BACKUP_FILE)
            except Exception:
                pass
            return True
        # If regular file backup exists, restore it
        if os.path.exists(RESOLVED_BACKUP_FILE):
            shutil.move(RESOLVED_BACKUP_FILE, resolv_path)
            info("Restored original /etc/resolv.conf")
            return True
        warn("No resolv.conf backup found")
        return False
    except Exception as e:
        warn(f"Failed to restore resolv.conf: {e}")
        return False

def configure_tor_dns():
    """Configure Tor to handle DNS requests properly."""
    try:
        # Ensure /etc/resolv.conf points to Tor
        with open('/etc/resolv.conf', 'w') as f:
            f.write("nameserver 127.0.0.1")
            f.write("options timeout:1")
        success("Configured /etc/resolv.conf to use Tor DNS")
        return True
    except Exception as e:
        warn(f"Failed to configure resolv.conf: {e}")
        return False

def set_tor_dnsport(port):
    """Set Tor DNSPort to specified port."""
    try:
        if not os.path.exists(TORRC_PATH):
            error(f"Tor config file not found at {TORRC_PATH}", fatal=True)
        # Validate port number
        port_int = int(port)
        if port_int < 1 or port_int > 65535:
            error(f"Invalid port number: {port}", fatal=True)

        # Backup original torrc if needed
        if not os.path.exists(TORRC_BACKUP_PATH):
            shutil.copy(TORRC_PATH, TORRC_BACKUP_PATH)
            info(f"Backed up original torrc to {TORRC_BACKUP_PATH}")

        # Get tor user permissions to restore later
        tor_stat = os.stat(TORRC_PATH)
        tor_uid = tor_stat.st_uid
        tor_gid = tor_stat.st_gid

        # Stop Tor service before modifying config
        subprocess.run(['systemctl', 'stop', 'tor'], check=False, timeout=15)

        # Read current config
        with open(TORRC_PATH, 'r') as f:
            lines = f.readlines()

        # Remove existing DNSPort lines (including commented ones)
        new_lines = [line for line in lines if not re.match(r'^\s*#?\s*DNSPort\b', line)]

        # Add our DNSPort setting
        new_lines.append(f'DNSPort 127.0.0.1:{port}')

        # Write updated config
        with open(TORRC_PATH, 'w') as f:
            f.writelines(new_lines)

        # Restore permissions
        os.chown(TORRC_PATH, tor_uid, tor_gid)
        success(f"Configured Tor to use DNSPort {port}")
        return True
    except Exception as e:
        error(f"Failed to set Tor DNSPort: {e}", fatal=True)

def ensure_tor_config():
    """Ensure Tor is properly configured for transparent proxying."""
    try:
        # Backup original torrc if needed
        if not os.path.exists(TORRC_BACKUP_PATH):
            if os.path.exists(TORRC_PATH):
                shutil.copy(TORRC_PATH, TORRC_BACKUP_PATH)
                info(f"Backed up original torrc to {TORRC_BACKUP_PATH}")

        # Read current config or start with empty
        current_config = ""
        if os.path.exists(TORRC_PATH):
            with open(TORRC_PATH, 'r') as f:
                current_config = f.read()

        # Remove any existing TorGhost block
        if TORRC_MARKER in current_config:
            pre_marker = current_config.split(TORRC_MARKER)[0]
            current_config = pre_marker.rstrip() + ""

        # Add our configuration block
        current_config += TORCONTENT

        # Write updated config
        with open(TORRC_PATH, 'w') as f:
            f.write(current_config)

        # Set proper permissions
        subprocess.run(['chown', 'tor:tor', TORRC_PATH], check=False, timeout=10)
        subprocess.run(['chmod', '644', TORRC_PATH], check=False, timeout=10)
        success("Tor configuration updated successfully")
        return True
    except Exception as e:
        error(f"Failed to configure Tor: {e}", fatal=True)

def detect_nat_conflicts():
    """Detect existing NAT rules that might conflict with TorGhost."""
    conflicts_found = False

    try:
        # More focused detection - only check for rules that will directly conflict

        # Check for Docker PREROUTING rules that are known to cause issues with Tor
        result = subprocess.run(['bash', '-c', "iptables -t nat -L PREROUTING -n -v 2>/dev/null"],
                               capture_output=True, text=True, timeout=15)
        if result.returncode == 0:
            for line in result.stdout.split('\n'):
                if 'DOCKER' in line.upper() and ('REDIRECT' in line.upper() or 'DNAT' in line.upper()):
                    warn(f"Docker NAT rule that may cause conflicts: {line.strip()}")
                    conflicts_found = True

        # Check if Tor's specific ports are already being redirected by other rules
        result = subprocess.run(['bash', '-c', "iptables -t nat -L -n 2>/dev/null"],
                               capture_output=True, text=True, timeout=15)
        if result.returncode == 0:
            for line in result.stdout.split('\n'):
                if any(port in line for port in ['9040', '9050', '9051', '5353']):
                    if 'REDIRECT' in line.upper() or 'DNAT' in line.upper():
                        # Check if this isn't one of our own rules by looking for Tor-specific patterns
                        if not any(our_port in line for our_port in ['9040', '5353']):
                            warn(f"Port already redirected by another rule: {line.strip()}")
                            conflicts_found = True

        # Check for applications already listening on Tor's ports
        result = subprocess.run(['ss', '-tuln'], capture_output=True, text=True, timeout=10)
        if result.returncode == 0:
            tor_ports = ['9040', '9050', '9051', '5353']
            for line in result.stdout.split('\n'):
                if 'LISTEN' in line:
                    for port in tor_ports:
                        if f':{port}' in line and ('0.0.0.0:' in line or '127.0.0.1:' in line):
                            # Exclude Tor itself if it's running
                            if 'tor' not in line.lower():
                                warn(f"Port {port} already in use: {line.strip()}")
                                conflicts_found = True

        return conflicts_found
    except Exception as e:
        warn(f"Could not inspect NAT rules or port usage: {e}")
        return False  # Return False to avoid false positives

def debug(msg):
    """Debug logging function (more verbose than info)"""
    if os.environ.get('TORGHOST_DEBUG', '0') == '1':
        print(f"{t()} {bcolors.BLUE}[DEBUG]{bcolors.ENDC} {msg}")
        logging.debug(msg)

# --- Checkpoint and recovery system ---
def ensure_checkpoint_dir():
    """Ensure checkpoint directory exists with secure permissions."""
    try:
        os.makedirs(CHECKPOINT_DIR, exist_ok=True)
        # Use more restrictive permissions to prevent unauthorized access
        os.chmod(CHECKPOINT_DIR, 0o700)
        # Ensure ownership is correct
        import pwd
        root_uid = pwd.getpwnam('root').pw_uid
        os.chown(CHECKPOINT_DIR, root_uid, root_uid)
    except Exception as e:
        warn(f"Could not create checkpoint dir: {e}")

def create_checkpoint(name, payload):
    """Create a checkpoint with given name and payload."""
    try:
        ensure_checkpoint_dir()
        checkpoint_path = os.path.join(CHECKPOINT_DIR, f"{name}-{int(time.time())}.json")
        # Add timestamp and sequence number
        payload['timestamp'] = time.time()
        with open(checkpoint_path, 'w') as f:
            json.dump(payload, f, indent=2)
        debug(f"Created checkpoint: {checkpoint_path}")
        return checkpoint_path
    except Exception as e:
        warn(f"Failed to create checkpoint {name}: {e}")
        return None

def save_iptables_snapshot():
    """Save current iptables and ip6tables state."""
    try:
        ensure_checkpoint_dir()
        ts = int(time.time())
        snapshot = {
            'time': ts,
            'ipv4': None,
            'ipv6': None
        }
        # Save IPv4 rules
        ipv4_file = os.path.join(CHECKPOINT_DIR, f"iptables-{ts}.rules")
        subprocess.run(['bash', '-c', f'iptables-save > {ipv4_file}'], check=True, timeout=15)
        snapshot['ipv4'] = ipv4_file
        # Save IPv6 rules
        ipv6_file = os.path.join(CHECKPOINT_DIR, f"ip6tables-{ts}.rules")
        subprocess.run(['bash', '-c', f'ip6tables-save > {ipv6_file}'], check=True, timeout=15)
        snapshot['ipv6'] = ipv6_file
        # Write to latest checkpoint
        with open(LATEST_CHECKPOINT, 'w') as f:
            json.dump(snapshot, f, indent=2)
        create_checkpoint('iptables_snapshot', snapshot)
        info(f"Saved iptables snapshot: {ipv4_file}, {ipv6_file}")
        return snapshot
    except Exception as e:
        warn(f"Failed to save iptables snapshot: {e}")
        return None

def restore_iptables_snapshot():
    """Restore iptables and ip6tables from latest checkpoint."""
    try:
        if not os.path.exists(LATEST_CHECKPOINT):
            debug("No iptables snapshot found to restore")
            return False
        with open(LATEST_CHECKPOINT, 'r') as f:
            snapshot = json.load(f)

        restored = False
        # Restore IPv4 rules if available
        ipv4_file = snapshot.get('ipv4')
        if ipv4_file and os.path.exists(ipv4_file):
            try:
                subprocess.run(['bash', '-c', f'iptables-restore < {ipv4_file}'], check=True, timeout=30)
                info(f"Restored IPv4 iptables from {ipv4_file}")
                restored = True
            except Exception as e:
                warn(f"Failed to restore IPv4 iptables: {e}")

        # Restore IPv6 rules if available
        ipv6_file = snapshot.get('ipv6')
        if ipv6_file and os.path.exists(ipv6_file):
            try:
                subprocess.run(['bash', '-c', f'ip6tables-restore < {ipv6_file}'], check=True, timeout=30)
                info(f"Restored IPv6 ip6tables from {ipv6_file}")
                restored = True
            except Exception as e:
                warn(f"Failed to restore IPv6 ip6tables: {e}")

        # Clean up checkpoint files
        try:
            if os.path.exists(LATEST_CHECKPOINT):
                os.remove(LATEST_CHECKPOINT)
        except Exception:
            pass
        return restored
    except Exception as e:
        warn(f"Failed to restore iptables snapshot: {e}")
        return False

def restore_system_state():
    """Attempt to restore system to pre-torghost state."""
    info("Attempting to restore system state...")
    restore_results = {
        'iptables': False,
        'resolv_conf': False,
        'resolved': False,
        'docker': False,
        'ipv6': False,
        'tor': False
    }

    # 1. Try to restore iptables first to restore network connectivity
    try:
        restore_results['iptables'] = restore_iptables_snapshot()
        if restore_results['iptables']:
            success("Restored iptables rules from checkpoint")
        else:
            warn("No iptables snapshot found, using default ACCEPT policy")
            try:
                subprocess.run(['bash', '-c', """
                iptables -P INPUT ACCEPT
                iptables -P FORWARD ACCEPT
                iptables -P OUTPUT ACCEPT
                iptables -t nat -F
                iptables -t mangle -F
                iptables -t raw -F
                iptables -F
                iptables -X
                ip6tables -P INPUT ACCEPT
                ip6tables -P FORWARD ACCEPT
                ip6tables -P OUTPUT ACCEPT
                ip6tables -t nat -F
                ip6tables -t mangle -F
                ip6tables -t raw -F
                ip6tables -F
                ip6tables -X
                """], check=True, timeout=20)
                success("Default firewall policies restored")
                restore_results['iptables'] = True
            except Exception as e:
                error(f"Failed to restore default firewall policies: {e}")
    except Exception as e:
        warn(f"Error restoring iptables: {e}")

    # 2. Restore resolv.conf
    try:
        restore_results['resolv_conf'] = restore_resolv_conf()
        if restore_results['resolv_conf']:
            success("Restored DNS configuration")
        else:
            warn("Could not restore original resolv.conf, creating a default one")
            try:
                with open('/etc/resolv.conf', 'w') as f:
                    f.write("nameserver 1.1.1.1\n")
                    f.write("nameserver 8.8.8.8\n")
                success("Created default resolv.conf")
                restore_results['resolv_conf'] = True
            except Exception as e:
                error(f"Failed to create default resolv.conf: {e}")
    except Exception as e:
        warn(f"Error restoring resolv.conf: {e}")

    # 3. Restore systemd-resolved if we stopped it, or ensure it's in proper state
    try:
        # First, check if we have a marker file indicating we stopped it
        if os.path.exists(RESOLVED_STOP_MARKER):
            restore_results['resolved'] = restore_systemd_resolved()
            if restore_results['resolved']:
                success("Restored systemd-resolved service")
        else:
            # No marker file, but if systemd-resolved was masked by us (in a previous failed attempt),
            # we should unmask it to restore normal operation
            info("Checking if systemd-resolved needs unmasking...")
            # Check the service status - if it's masked, unmask it
            result = subprocess.run(['systemctl', 'is-enabled', 'systemd-resolved'],
                                  capture_output=True, text=True, timeout=10)
            if result.stdout.strip() == 'masked':
                info("systemd-resolved is currently masked, unmasking it...")
                subprocess.run(['systemctl', 'unmask', 'systemd-resolved'], check=False, timeout=10)
                subprocess.run(['systemctl', 'start', 'systemd-resolved'], check=False, timeout=10)
                success("systemd-resolved unmasked and started")
                restore_results['resolved'] = True
            else:
                info("systemd-resolved is not masked, leaving as-is")
    except Exception as e:
        warn(f"Error handling systemd-resolved during restore: {e}")
        # Try a force start anyway
        try:
            subprocess.run(['systemctl', 'start', 'systemd-resolved'], check=False, timeout=10)
            success("Started systemd-resolved service")
            restore_results['resolved'] = True
        except Exception as e2:
            warn(f"Could not start systemd-resolved: {e2}")

    # 4. Restore Docker if we stopped it
    try:
        restore_results['docker'] = restore_docker_if_stopped()
        if restore_results['docker']:
            success("Restored Docker service")
    except Exception as e:
        warn(f"Error restoring Docker: {e}")

    # 5. Restore IPv6 settings
    try:
        restore_ipv6()
        restore_results['ipv6'] = True
    except Exception as e:
        warn(f"Error restoring IPv6 settings: {e}")

    # 6. Stop Tor service
    try:
        subprocess.run(['systemctl', 'stop', 'tor'], check=False, timeout=10)
        info("Stopped Tor service")
        restore_results['tor'] = True
    except Exception as e:
        warn(f"Error stopping Tor service: {e}")

    success("System restoration attempted. Network connectivity should be restored.")
    debug(f"Restore results: {restore_results}")

# --- Helper function for Tor startup and DNS configuration ---
def _configure_and_start_tor_with_dns():
    """
    Handles Tor configuration, startup, and DNS readiness verification.
    Returns the DNS port used (5353 or 53) and success status.
    """
    info("Configuring and starting Tor...")
    # 1. Configure Tor (writes torrc)
    ensure_tor_config()
    create_checkpoint('tor_configured', {'torrc_path': TORRC_PATH})

    # 2. Start Tor service
    info("Starting Tor service...")
    try:
        # First, force stop any existing Tor process to free up ports
        info("Stopping any existing Tor service to free ports...")
        subprocess.run(['systemctl', 'stop', 'tor'], check=False, timeout=10)
        # Wait a moment for ports to be released
        time.sleep(2)

        # Check for any remaining Tor processes
        subprocess.run(['pkill', '-f', 'tor'], check=False, timeout=5)
        time.sleep(1)

        # Now check if the required ports are free using ss (more reliable than wait_for_port)
        info("Checking if Tor ports are available...")
        result = subprocess.run(['ss', '-tuln'], capture_output=True, text=True, timeout=10)
        for port in [9050, 9051, 9040, 5353]:
            for line in result.stdout.split('\n'):
                if f':{port}' in line and ('LISTEN' in line or 'UNCONN' in line):
                    # Check if it's Tor using the port (not a conflict) or another service
                    if 'tor' not in line.lower():
                        error(f"Port {port} is in use by another service: {line.strip()}", fatal=True)

        # Explicitly check Tor configuration before starting
        info("Verifying Tor configuration is valid...")
        if not os.path.exists('/etc/tor/torrc'):
            error("Tor configuration file /etc/tor/torrc does not exist", fatal=True)

        # Set proper permissions for Tor directories before starting
        info("Setting proper permissions for Tor directories...")
        try:
            import pwd
            tor_uid = pwd.getpwnam('tor').pw_uid
            tor_gid = pwd.getpwnam('tor').pw_gid

            # Ensure Tor directories have correct ownership
            tor_dirs = ['/var/lib/tor', '/run/tor', '/etc/tor']
            for tor_dir in tor_dirs:
                if os.path.exists(tor_dir):
                    os.chown(tor_dir, tor_uid, tor_gid)
        except KeyError:
            warn("Tor user not found, skipping permission setup")
        except Exception as perm_error:
            warn(f"Could not set Tor directory permissions: {perm_error}")

        # Start Tor service
        subprocess.run(['systemctl', 'start', 'tor'], check=True, timeout=30)
        # Wait briefly then restart to apply our configuration
        time.sleep(1)
        subprocess.run(['systemctl', 'restart', 'tor'], check=True, timeout=30)

        # Verify Tor service is running
        tor_status_result = subprocess.run(['systemctl', 'is-active', 'tor'], capture_output=True, text=True, timeout=10)
        if tor_status_result.stdout.strip() != 'active':
             error(f"Tor service failed to start or is not active after restart. Status: {tor_status_result.stdout.strip()}", fatal=True)
        success("Tor service started and verified as active")
        create_checkpoint('tor_started', {'time': time.time()})
    except Exception as e:
        error(f"Failed to start Tor service: {e}. "
             "Check journalctl -u tor for details. "
             "Common issues: "
             "- Port conflicts (another service using 9040, 9050, 9051) "
             "- Missing permissions on /var/lib/tor or /run/tor "
             "- Configuration errors in /etc/tor/torrc "
             "- Tor service not installed or missing dependencies",
             fatal=True)

    # 3. Wait for Tor required ports to be ready
    info("Waiting for Tor ports to be ready...")
    # Wait for control port (9051)
    if not wait_for_port('127.0.0.1', 9051, timeout=60):
        error("Tor control port 9051 did not become available. Check 'journalctl -u tor' for errors.",
             fatal=True)
    success("Tor control port 9051 is ready")

    # Wait for SOCKS port (9050)
    if not wait_for_port('127.0.0.1', 9050, timeout=30):
        error("Tor SOCKS port 9050 did not become available. Check 'journalctl -u tor' for errors.",
             fatal=True)
    success("Tor SOCKS port 9050 is ready")

    # Wait for transparent proxy port (9040)
    if not wait_for_port('127.0.0.1', 9040, timeout=30):
        error("Tor transparent proxy port 9040 did not become available. Check 'journalctl -u tor' for errors.",
             fatal=True)
    success("Tor transparent proxy port 9040 is ready")

    # 4. Wait for Tor bootstrap
    if not wait_for_bootstrap(timeout=180):
        error("Tor failed to bootstrap. Check 'journalctl -u tor' for detailed errors.", 
             fatal=True)

    # 5. Determine DNS Port and wait for readiness
    info("Checking Tor DNS readiness on port 5353...")
    dns_port = 5353
    if not wait_for_port('127.0.0.1', 5353, timeout=30):
        warn("Tor DNS not ready on port 5353, switching to port 53...")
        set_tor_dnsport(53)
        # Restart Tor after config change
        try:
            subprocess.run(['systemctl', 'restart', 'tor'], check=True, timeout=30)
            # Verify restarted Tor service is running
            tor_status_result = subprocess.run(['systemctl', 'is-active', 'tor'], capture_output=True, text=True, timeout=10)
            if tor_status_result.stdout.strip() != 'active':
                 error(f"Tor service failed to start after DNSPort change or is not active. Status: {tor_status_result.stdout.strip()}", fatal=True)
        except Exception as e:
            error(f"Failed to restart Tor after changing DNSPort: {e}", fatal=True)
        
        if not wait_for_bootstrap(timeout=60):
            error("Tor failed to bootstrap after switching to port 53", fatal=True)
        if not wait_for_port('127.0.0.1', 53, timeout=30):
            error("Tor DNS not available on either port 5353 or 53. Check Tor logs.", 
                 fatal=True)
        dns_port = 53
        success("Using Tor DNS on port 53")
    else:
        success("Tor DNS ready on port 5353")

    return dns_port, True


# --- Core operational functions ----------------------------------------------
def prepare_system_for_tor():
    """Completely prepare the system for Tor by stopping interfering services."""
    info("Preparing system for Tor by stopping interfering services...")

    # 1. Verify systemd-resolved is still stopped and masked (should have been done in start_torghost)
    info("Verifying systemd-resolved is still masked...")
    mask_result = subprocess.run(['systemctl', 'is-enabled', 'systemd-resolved'], capture_output=True, text=True, timeout=10)
    if mask_result.stdout.strip() != 'masked':
        warn("systemd-resolved is not masked, masking it now...")
        subprocess.run(['systemctl', 'mask', 'systemd-resolved'], check=False, timeout=10)
        subprocess.run(['systemctl', 'disable', 'systemd-resolved'], check=False, timeout=10)

    # Check that it's not running
    result = subprocess.run(['systemctl', 'is-active', 'systemd-resolved'], capture_output=True, text=True, timeout=10)
    if result.stdout.strip() == 'active':
        warn("systemd-resolved is still active, stopping it...")
        subprocess.run(['systemctl', 'stop', 'systemd-resolved'], check=False, timeout=10)
        # Force kill any remaining processes
        subprocess.run(['pkill', '-f', 'systemd-resolve'], check=False, timeout=5)
        time.sleep(1)

    # 2. Check for processes using port 53
    info("Checking for processes using port 53...")
    try:
        result = subprocess.run(['ss', '-lun', '( sport = :domain )'],
                               capture_output=True, text=True, timeout=10)
        if 'LISTEN' in result.stdout or 'UNCONN' in result.stdout:
            warn("Port 53 appears to be in use. Attempting to identify process:")
            subprocess.run(['ss', '-lunp', '( sport = :domain )'], timeout=10)
        # Final verification
        result = subprocess.run(['ss', '-lun', '( sport = :domain )'],
                               capture_output=True, text=True, timeout=10)
        if 'LISTEN' in result.stdout or 'UNCONN' in result.stdout:
             error("Port 53 is still occupied. Please check manually with 'sudo ss -lunp \"sport = :domain\"'", fatal=True)
        else:
            success("Port 53 is free")
    except Exception as e:
        warn(f"Error checking port 53 status: {e}")

    # 3. Ensure resolv.conf is a regular file pointing to localhost
    try:
        # Remove symlink if it exists
        if os.path.islink('/etc/resolv.conf'):
            info("Removing systemd-resolved symlink at /etc/resolv.conf")
            os.remove('/etc/resolv.conf')
        # Create a clean resolv.conf
        with open('/etc/resolv.conf', 'w') as f:
            f.write("nameserver 127.0.0.1")
            f.write("options timeout:1")
        success("Created clean /etc/resolv.conf pointing to localhost")
    except Exception as e:
        error(f"Failed to create clean resolv.conf: {e}", fatal=True)

    # 4. Verify port 53 is free AFTER stopping resolved
    info("Verifying port 53 is free after stopping resolved...")
    try:
        result = subprocess.run(['ss', '-lun', '( sport = :domain )'],
                               capture_output=True, text=True, timeout=10)
        if 'LISTEN' in result.stdout or 'UNCONN' in result.stdout:
            warn("Port 53 appears to still be in use after stopping resolved. Attempting to identify process:")
            subprocess.run(['ss', '-lunp', '( sport = :domain )'], timeout=10)
            # Try to kill any remaining processes using port 53
            subprocess.run(['pkill', '-f', 'systemd-resolved'], check=False, timeout=10)
            time.sleep(2)
        # Final verification
        result = subprocess.run(['ss', '-lun', '( sport = :domain )'],
                               capture_output=True, text=True, timeout=10)
        if 'LISTEN' in result.stdout or 'UNCONN' in result.stdout:
            error("Port 53 is still occupied after cleanup attempts. Please check manually with 'sudo ss -lunp \"sport = :domain\"'", fatal=True)
        else:
            success("Port 53 is now free")
    except Exception as e:
        warn(f"Error checking port 53 status: {e}")

    return True

def start_torghost():
    """
    Start TorGhost with all necessary preparatory steps
    """
    logo()
    info("Starting TorGhost...")

    try:
        # --- CRITICAL PRE-START CHECKS ---
        # Check if systemd-resolved is running and potentially interfering
        info("Checking for systemd-resolved interference...")
        result = subprocess.run(['systemctl', 'is-active', 'systemd-resolved'], capture_output=True, text=True, timeout=10)
        if result.stdout.strip() == 'active':
            warn("systemd-resolved is currently active, this will interfere with Tor")
            # Check if it's masked
            mask_result = subprocess.run(['systemctl', 'is-enabled', 'systemd-resolved'], capture_output=True, text=True, timeout=10)
            if mask_result.stdout.strip() == 'masked':
                warn("systemd-resolved is masked but still running - this is unexpected")
                # Kill any remaining processes and restart
                subprocess.run(['pkill', '-f', 'systemd-resolve'], check=False, timeout=5)
                subprocess.run(['systemctl', 'stop', 'systemd-resolved'], check=False, timeout=10)
            else:
                warn("systemd-resolved should have been stopped by TorGhost previously, stopping now...")
                # This suggests TorGhost was interrupted in a previous run, so we'll stop it
                subprocess.run(['systemctl', 'stop', 'systemd-resolved'], check=False, timeout=10)

        # IMMEDIATELY mask systemd-resolved to prevent it from starting again
        info("Masking systemd-resolved to prevent conflicts...")
        subprocess.run(['systemctl', 'mask', 'systemd-resolved'], check=False, timeout=10)
        subprocess.run(['systemctl', 'disable', 'systemd-resolved'], check=False, timeout=10)
        success("systemd-resolved masked and disabled")

        # 1. Stop Docker completely with thorough cleanup
        if is_docker_active():
            info("Docker service is running - this WILL interfere with Tor transparent proxying")
            info("Stopping Docker and cleaning up its iptables rules...")
            # Stop docker service
            subprocess.run(['systemctl', 'stop', 'docker'], check=False, timeout=15)
            # Remove ALL docker-related iptables rules
            try:
                # Clean nat table completely
                subprocess.run(['iptables', '-t', 'nat', '-F'], check=False, timeout=10)
                subprocess.run(['iptables', '-t', 'nat', '-X', 'DOCKER'], check=False, timeout=10)
                # Clean filter table DOCKER rules
                subprocess.run(['iptables', '-F', 'DOCKER'], check=False, timeout=10)
                subprocess.run(['iptables', '-X', 'DOCKER'], check=False, timeout=10)
                # Remove any docker chains
                subprocess.run(['bash', '-c', 'iptables -L | grep "^Chain DOCKER" | cut -d" " -f2 | xargs -r -n1 iptables -X'], check=False, timeout=15)
                success("Docker iptables rules cleaned up")
            except Exception as e:
                warn(f"Failed to clean Docker iptables rules: {e}")
        else:
            info("Docker service is not running - good for Tor operation")

        # 2. Create checkpoint directory early
        ensure_checkpoint_dir()

        # 3. Setup logging
        logging.basicConfig(
            filename='/var/log/torghost.log',
            level=logging.DEBUG,
            format='%(asctime)s - %(levelname)s - %(message)s'
        )

        # 4. Initial checkpoint
        initial_checkpoint = {
            'started_at': time.time(),
            'user': os.environ.get('SUDO_USER', os.environ.get('USER', 'unknown')),
            'action': 'start'
        }
        create_checkpoint('start_init', initial_checkpoint)

        # 5. Save current iptables state
        info("Saving current firewall state...")
        save_iptables_snapshot()
        create_checkpoint('iptables_saved', {'note': 'original firewall state saved'})

        # 6. Check for conflicting NAT rules
        if detect_nat_conflicts():
            error("Conflicting NAT rules detected. This could cause network loops or break connectivity. "
                 "Please review your firewall rules or run in a clean environment.", fatal=True)

        # 7. Prepare system (stop resolved, handle resolv.conf, check port 53)
        prepare_system_for_tor()

        # 8. Stop Docker if running (moved earlier, but confirmation checkpoint here)
        stop_docker_and_wait()

        # 9-14. Moved to _configure_and_start_tor_with_dns
        dns_port, tor_success = _configure_and_start_tor_with_dns()
        if not tor_success:
            error("Failed to configure and start Tor with DNS", fatal=True)

        # 15. Configure DNS (must happen *after* Tor DNS is ready)
        info("Configuring system DNS to use Tor...")
        if not configure_tor_dns():
            error("Failed to configure system DNS. System may lose internet connectivity.",
                 fatal=True)
        create_checkpoint('dns_configured', {'dns_port_used': dns_port})

        # 16. Get Tor UID
        info("Getting Tor user UID...")
        try:
            tor_uid = subprocess.run(['id', '-u', 'tor'],
                                   capture_output=True, text=True, check=True, timeout=10).stdout.strip()
            success(f"Tor UID: {tor_uid}")
        except Exception as e:
            error(f"Could not get Tor UID: {e}", fatal=True)

        # 17. Disable IPv6
        disable_ipv6()

        # 18. Apply iptables rules
        info("Applying firewall rules to route traffic through Tor...")
        iptables_script = IPTABLESSCRIPT.format(tor_uid=tor_uid, dns_port=dns_port)
        try:
            subprocess.run(['bash', '-c', iptables_script], check=True, timeout=30)
            success("Firewall rules applied successfully")
            create_checkpoint('iptables_applied', {'dns_port': dns_port, 'tor_uid': tor_uid})
        except Exception as e:
            error(f"Failed to apply firewall rules: {e}", fatal=True)

        # 19. Verify connectivity
        info("Verifying connectivity through Tor...")
        current_ip = get_ip()

        # 20. Final checkpoint
        final_checkpoint = {
            'completed_at': time.time(),
            'current_ip': current_ip,
            'dns_port': dns_port,
            'status': 'active'
        }
        create_checkpoint('start_complete', final_checkpoint)

        success(f"TorGhost started successfully! All traffic is now routed through Tor.")
        info(f"Your current public IP is: {current_ip}")
        info("Run 'sudo torghost stop' to revert all changes.")

    except Exception as e:
        error(f"TorGhost startup failed with error: {e}", fatal=True)

def stop_torghost(monitor=False, interval=10):
    """
    Stop TorGhost and restore system to original state.
    """
    logo()
    info("Stopping TorGhost and restoring system state")
    # Setup logging
    logging.basicConfig(
        filename='/var/log/torghost.log',
        level=logging.DEBUG,
        format='%(asctime)s - %(levelname)s - %(message)s'
    )
    # Initial checkpoint
    initial_checkpoint = {
        'started_at': time.time(),
        'user': os.environ.get('SUDO_USER', os.environ.get('USER', 'unknown')),
        'action': 'stop'
    }
    create_checkpoint('stop_init', initial_checkpoint)

    # 1. Stop Tor service first
    info("Stopping Tor service...")
    try:
        subprocess.run(['systemctl', 'stop', 'tor'], check=True, timeout=15)
        success("Tor service stopped")
    except Exception as e:
        warn(f"Could not stop Tor service: {e}")

    # 2. Restore original firewall rules
    info("Restoring original firewall rules...")
    if not restore_iptables_snapshot():
        warn("No iptables snapshot found, using default ACCEPT policy")
        try:
            subprocess.run(['bash', '-c', """
            iptables -P INPUT ACCEPT
            iptables -P FORWARD ACCEPT
            iptables -P OUTPUT ACCEPT
            iptables -t nat -F
            iptables -t mangle -F
            iptables -t raw -F
            iptables -F
            iptables -X
            ip6tables -P INPUT ACCEPT
            ip6tables -P FORWARD ACCEPT
            ip6tables -P OUTPUT ACCEPT
            ip6tables -t nat -F
            ip6tables -t mangle -F
            ip6tables -t raw -F
            ip6tables -F
            ip6tables -X
            """], check=True, timeout=20)
            success("Default firewall policies restored")
        except Exception as e:
            error(f"Failed to restore default firewall policies: {e}", fatal=True)
    else:
        success("Restored original firewall rules from checkpoint")

    # 3. Restore resolv.conf
    info("Restoring DNS configuration...")
    if not restore_resolv_conf():
        warn("Could not restore original resolv.conf, creating a default one")
        try:
            with open('/etc/resolv.conf', 'w') as f:
                f.write("nameserver 1.1.1.1\n")
                f.write("nameserver 8.8.8.8\n")
            success("Created default resolv.conf")
        except Exception as e:
            error(f"Failed to create default resolv.conf: {e}", fatal=True)
    else:
        success("Restored original DNS configuration")

    # 4. Restore systemd-resolved if we stopped it
    if restore_systemd_resolved():
        success("Restored systemd-resolved service")

    # 5. Restore Docker if we stopped it
    if restore_docker_if_stopped():
        success("Restored Docker service")

    # 6. Restore IPv6 settings
    restore_ipv6()

    # 7. Clean up Tor configuration
    info("Cleaning up Tor configuration...")
    try:
        if os.path.exists(TORRC_BACKUP_PATH) and os.path.exists(TORRC_PATH):
            # Read current config
            with open(TORRC_PATH, 'r') as f:
                current_config = f.read()
            # If it contains our marker, restore from backup
            if TORRC_MARKER in current_config:
                shutil.move(TORRC_BACKUP_PATH, TORRC_PATH)
                info("Restored original Tor configuration")
            else:
                # No need to restore, just remove backup
                os.remove(TORRC_BACKUP_PATH)
    except Exception as e:
        warn(f"Could not restore Tor configuration: {e}")

    # 8. Verify connectivity
    info("Verifying system connectivity...")
    current_ip = get_ip()

    # 9. Final checkpoint
    final_checkpoint = {
        'completed_at': time.time(),
        'current_ip': current_ip,
        'status': 'stopped'
    }
    create_checkpoint('stop_complete', final_checkpoint)

    success(f"TorGhost stopped successfully! System restored to original state.")
    info(f"Your current public IP is: {current_ip}")

def switch_tor():
    """
    Request a new Tor circuit to change exit node and IP address.
    """
    logo()
    info("Requesting new Tor circuit...")
    try:
        with Controller.from_port(port=9051) as controller:
            try:
                controller.authenticate()
                controller.signal(Signal.NEWNYM)
                success("New Tor circuit created")
                time.sleep(10)  # Allow time for circuit to establish
            except Exception as e:
                error(f"Failed to authenticate with Tor control port: {e}", fatal=True)
    except Exception as e:
        error(f"Could not connect to Tor control port: {e}", fatal=True)
    current_ip = get_ip()
    success(f"Your new public IP through Tor is: {current_ip}")

def show_status():
    """
    Show current TorGhost status.
    """
    logo()
    print(f"{bcolors.BOLD}TorGhost Status:{bcolors.ENDC}")
    # Check if TorGhost is active (look for checkpoints or markers)
    is_active = False
    markers = [
        RESOLVED_STOP_MARKER,
        DOCKER_STOP_MARKER,
        LATEST_CHECKPOINT
    ]
    for marker in markers:
        if os.path.exists(marker):
            is_active = True
            break
    # Check Tor service status
    try:
        tor_status = subprocess.run(['systemctl', 'is-active', 'tor'],
                                  capture_output=True, text=True, timeout=10).stdout.strip()
    except Exception:
        tor_status = "unknown"
    # Get current IP
    current_ip = get_ip()

    print(f"TorGhost Active: {bcolors.GREEN if is_active else bcolors.RED}{is_active}{bcolors.ENDC}")
    print(f"Tor Service: {bcolors.GREEN if tor_status == 'active' else bcolors.RED}{tor_status}{bcolors.ENDC}")
    print(f"Current Public IP: {bcolors.GREEN}{current_ip}{bcolors.ENDC}")

    if is_active:
        print(f"{bcolors.YELLOW}TorGhost is currently active. All traffic is being routed through Tor.{bcolors.ENDC}")
        print(f"Run 'sudo torghost stop' to restore normal networking.")
    else:
        print(f"{bcolors.GREEN}TorGhost is not active. System is using normal networking.{bcolors.ENDC}")
        print(f"Run 'sudo torghost start' to route all traffic through Tor.")

def diagnose_system():
    """
    Run comprehensive diagnostics to identify potential issues.
    """
    logo()
    info("Running comprehensive diagnostics...")
    def run_cmd(cmd, description):
        print(f"{bcolors.BOLD}{description}:{bcolors.ENDC}")
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=15)
            print(result.stdout)
            if result.stderr:
                print(f"{bcolors.RED}Errors:{bcolors.ENDC}")
                print(result.stderr)
        except subprocess.TimeoutExpired:
            print(f"{bcolors.RED}Command timed out: {' '.join(cmd) if isinstance(cmd, list) else cmd}{bcolors.ENDC}")
        except Exception as e:
            print(f"{bcolors.RED}Error running command: {e}{bcolors.ENDC}")

    # 1. Network interfaces
    run_cmd(['ip', 'addr', 'show'], "Network interfaces")

    # 2. DNS configuration
    print(f"{bcolors.BOLD}DNS Configuration:{bcolors.ENDC}")
    try:
        print("/etc/resolv.conf contents:")
        with open('/etc/resolv.conf', 'r') as f:
            print(f.read())
    except Exception as e:
        print(f"Error reading resolv.conf: {e}")

    # 3. systemd-resolved status
    run_cmd(['systemctl', 'status', 'systemd-resolved', '--no-pager'], "systemd-resolved status")

    # 4. Docker status
    run_cmd(['systemctl', 'status', 'docker', '--no-pager'], "Docker status")

    # 5. Tor status
    run_cmd(['systemctl', 'status', 'tor', '--no-pager'], "Tor service status")

    # 6. Check listening ports
    print(f"{bcolors.BOLD}Listening ports (relevant to TorGhost):{bcolors.ENDC}")
    ports = ['53', '5353', '9040', '9050', '9051']
    for port in ports:
        try:
            result = subprocess.run(['ss', '-ltnup', f'src :{port}'],
                                  capture_output=True, text=True, timeout=10)
            if result.stdout.strip():
                print(f"Port {port}:")
                print(result.stdout.strip())
            else:
                print(f"Port {port}: Not listening")
        except Exception as e:
            print(f"Error checking port {port}: {e}")

    # 7. iptables rules
    print(f"{bcolors.BOLD}Current iptables NAT rules:{bcolors.ENDC}")
    try:
        result = subprocess.run(['iptables', '-t', 'nat', '-L', '-n', '-v'],
                              capture_output=True, text=True, timeout=15)
        print(result.stdout)
    except Exception as e:
        print(f"Error getting iptables rules: {e}")

    # 8. Check for TorGhost markers
    print(f"{bcolors.BOLD}TorGhost markers and checkpoints:{bcolors.ENDC}")
    markers = [
        RESOLVED_STOP_MARKER,
        DOCKER_STOP_MARKER,
        LATEST_CHECKPOINT,
        IPV6_BACKUP_FILE,
        RESOLVED_BACKUP_FILE,
        TORRC_BACKUP_PATH
    ]
    for marker in markers:
        if os.path.exists(marker):
            print(f"{bcolors.GREEN}✓ Found: {marker}{bcolors.ENDC}")
            try:
                if marker.endswith('.json'):
                    with open(marker, 'r') as f:
                        print(json.dumps(json.load(f), indent=2))
                elif os.path.isfile(marker):
                    with open(marker, 'r') as f:
                        print(f"Contents: {f.read().strip()}")
            except Exception as e:
                print(f"  Error reading file: {e}")
        else:
            print(f"{bcolors.RED}✗ Missing: {marker}{bcolors.ENDC}")

    info("Diagnostics complete. Review the output above for potential issues.")

def wait_for_bootstrap(timeout=180, poll_interval=2):
    """
    Wait for Tor to finish bootstrapping.
    """
    info("Waiting for Tor to bootstrap...")
    deadline = time.time() + timeout
    last_progress = -1
    while time.time() < deadline:
        try:
            with Controller.from_port(port=9051) as controller:
                controller.authenticate()
                # Get bootstrap status
                bootstrap_status = controller.get_info("status/bootstrap-phase")
                progress_match = re.search(r'PROGRESS=(\d+)', bootstrap_status)
                if progress_match:
                    progress = int(progress_match.group(1))
                    # Only print if progress has changed significantly
                    if progress != last_progress and (progress % 10 == 0 or progress > last_progress):
                        info(f"Tor bootstrap progress: {progress}%")
                        last_progress = progress
                    if progress >= 100:
                        success("Tor bootstrap completed (100%)")
                        return True
        except Exception as e:
            debug(f"Error checking bootstrap status: {e}")
        time.sleep(poll_interval)
    warn("Tor bootstrap timeout reached")
    return False

def check_dns_leaks(interval=10):
    """
    Continuously monitor for DNS leaks by checking if external IP changes.
    """
    logo()
    info(f"Starting DNS leak monitoring (checking every {interval} seconds)...")
    info("Press Ctrl+C to stop monitoring")

    initial_ip = None
    try:
        while True:
            current_ip = get_ip()
            if initial_ip is None:
                initial_ip = current_ip
                success(f"Initial IP set to: {initial_ip}")
            elif current_ip != initial_ip:
                warn(f"POTENTIAL DNS LEAK DETECTED! IP changed from {initial_ip} to {current_ip}")
            else:
                info(f"IP unchanged: {current_ip} (no apparent leak)")

            time.sleep(interval)
    except KeyboardInterrupt:
        info("DNS leak monitoring stopped by user")
        return

# --- Main execution flow ----------------------------------------------------
def main():
    # Setup signal handler for clean shutdown
    signal.signal(signal.SIGINT, sigint_handler)
    signal.signal(signal.SIGTERM, lambda signum, frame: shutdown())

    # Check root privileges for commands that need them
    command = sys.argv[1].lower() if len(sys.argv) > 1 else 'status'
    requires_root = ['start', 'stop', 'switch', 'diag', 'diagnose', 'check-leak']
    if command in requires_root and os.geteuid() != 0:
        print(f"{bcolors.RED}{bcolors.BOLD}You must run this command as root.{bcolors.ENDC}")
        print("Use sudo: sudo torghost", command)
        sys.exit(1)

    # Command dispatch
    if command == "start":
        print_dev_warning()
        start_torghost()
    elif command == "stop":
        # Check for monitor mode
        monitor_mode = False
        interval = 10
        if len(sys.argv) >= 3 and sys.argv[2].lower() in ('monitor', 'watch'):
            monitor_mode = True
            if len(sys.argv) >= 4:
                try:
                    interval = int(sys.argv[3])
                except ValueError:
                    warn("Invalid interval, using default 10 seconds")
        stop_torghost(monitor=monitor_mode, interval=interval)
    elif command == "switch":
        switch_tor()
    elif command == "status":
        show_status()
    elif command in ["diag", "diagnose"]:
        diagnose_system()
    elif command in ["check-leak", "checkleak"]:
        interval = 10
        if len(sys.argv) >= 3:
            try:
                interval = int(sys.argv[2])
            except ValueError:
                warn("Invalid interval, using default 10 seconds")
        # Run continuous DNS leak monitoring
        info(f"Starting continuous DNS leak monitoring (interval: {interval}s)...")
        check_dns_leaks(interval)
    else:
        print_dev_warning()
        usage()

if __name__ == "__main__":
    main()
