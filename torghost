#!/usr/bin/env python3
"""
TorGhost - Clean and Working Version

This script controls system-level configuration to route traffic through Tor.
It must be run as root for actions that modify system services, networking,
and firewall rules.

Detailed comments have been added throughout to explain the purpose of each
section and the reasoning behind key operations.
"""

# --- Standard library imports ------------------------------------------------
# os, sys: file paths, exit, effective UID checks
# subprocess: run system commands (systemctl, iptables, curl, id)
# time: used for timestamps in logging
# signal: capture Ctrl-C / SIGINT to perform a clean shutdown
# shutil: file operations such as copying and moving files (resolv.conf backup)
import os
import sys
import subprocess
import time
import signal
import shutil

# --- Third-party dependency check -------------------------------------------
# 'stem' is required to control the Tor process via its control port and to
# request new circuits (NEWNYM). Rather than attempting to auto-install here,
# provide a clear message to the operator if it's missing and exit with guidance.
try:
    from stem import Signal
    from stem.control import Controller
except Exception:
    # Informative guidance for installing the dependency
    print("Required Python package 'stem' is not installed.")
    print("On Arch: sudo pacman -S python-stem")
    print("Or with pip: pip install stem")
    sys.exit(1)


# --- Terminal color helper class --------------------------------------------
# bcolors provides a small, local set of escape sequences to color terminal
# output. Used to make status and error messages easier to spot.
class bcolors:
    BLUE = '\033[94m'
    GREEN = '\033[92m'
    RED = '\033[31m'
    YELLOW = '\033[93m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'

# User feedback helper functions (timestamped, colored)
def info(msg):
    """Informational status message."""
    print(f"{t()} {bcolors.BLUE}{msg}{bcolors.ENDC}")

def success(msg):
    """Success message."""
    print(f"{t()} {bcolors.GREEN}{msg}{bcolors.ENDC}")

def warn(msg):
    """Non-fatal warning."""
    print(f"{t()} {bcolors.YELLOW}{msg}{bcolors.ENDC}")

def error(msg, fatal=False):
    """Error message; if fatal True, exit after printing."""
    print(f"{t()} {bcolors.RED}{msg}{bcolors.ENDC}")
    if fatal:
        sys.exit(1)


# --- Utility functions -------------------------------------------------------
def t():
    """
    Return a compact timestamp string for human-readable logs.

    Example: [14:22:09]
    """
    return "[" + time.strftime('%H:%M:%S') + "]"


def sigint_handler(signum, frame):
    """
    Signal handler for SIGINT (Ctrl-C). Ensures a polite shutdown message
    and exits cleanly by delegating to shutdown().
    """
    print('\nUser interrupt! Shutting down')
    shutdown()


def shutdown():
    """
    Perform any necessary cleanup (if added later) and exit the program.
    Currently prints a timestamped shutdown message and exits.
    """
    print(f"\n{t()} Shutting down torghost")
    sys.exit()


def logo():
    """
    Clear the terminal and print the ASCII banner + version info.
    Kept in a function so it can be reused before interactive usage/help text.
    """
    os.system("clear")
    print(f"{bcolors.RED}{bcolors.BOLD}")
    print(r"""
                                                     
▄▄▄▄▄▄▄▄▄           ▄▄▄▄▄▄▄  ▄▄                      
▀▀▀███▀▀▀          ███▀▀▀▀▀  ██                 ██   
   ███ ▄███▄ ████▄ ███       ████▄ ▄███▄ ▄█▀▀▀ ▀██▀▀ 
   ███ ██ ██ ██ ▀▀ ███  ███▀ ██ ██ ██ ██ ▀███▄  ██   
   ███ ▀███▀ ██    ▀██████▀  ██ ██ ▀███▀ ▄▄▄█▀  ██   
                                                            
    v3.0 - rewritten by nzkritik for Arch Linux
    """)
    print(f"{bcolors.ENDC}")


def usage():
    """
    Print usage instructions and exit. Shows the logo and a basic help message.
    """
    logo()
    print("""
    USAGE:
        sudo torghost start   (start torghost)
        sudo torghost stop    (stop torghost) 
        sudo torghost switch  (switch IP)
        torghost status       (show status)
    """)
    sys.exit()


def get_ip():
    """
    Query an external service (api.ipify.org) to fetch the public IP.
    Uses curl via subprocess; if curl is missing, warn and return "Unknown".
    """
    # quick check for curl to provide actionable feedback
    if shutil.which('curl') is None:
        warn("curl not found — cannot query external IP (install curl to enable).")
        return "Unknown"

    try:
        result = subprocess.run(['curl', '-s', 'https://api.ipify.org'],
                                capture_output=True, text=True, check=True)
        ip = result.stdout.strip()
        if not ip:
            warn("ipify returned empty response.")
            return "Unknown"
        return ip
    except subprocess.CalledProcessError as e:
        warn(f"Failed to query external IP: {e}")
        return "Unknown"
    except Exception as e:
        warn(f"Unexpected error while querying IP: {e}")
        return "Unknown"


# --- Core operational functions ----------------------------------------------
def start_torghost():
    """
    Start TorGhost by:
    1. Appending a Tor configuration block (torrc) if not already present.
    2. Backing up and modifying /etc/resolv.conf to point DNS to localhost.
    3. Starting the Tor systemd service.
    4. Determining the 'tor' user UID for firewall exclusions.
    5. Applying iptables and ip6tables rules to route DNS and TCP traffic
       through Tor while excluding local/private networks and the tor user.
    """

    # --- torrc configuration ------------------------------------------------
    # We write a small configuration block to ensure Tor listens on the
    # ports we expect (TransPort 9040, DNSPort 53, ControlPort 9051) and
    # that VirtualAddrNetwork/AutomapHostsOnResolve are enabled.
    torrc_path = '/etc/tor/torrc'
    torrc_marker = '## TorGhost Configuration'
    torrc_content = f"""
{torrc_marker}
VirtualAddrNetwork 10.0.0.0/10
AutomapHostsOnResolve 1
TransPort 9040
DNSPort 53
ControlPort 9051
"""

    info("Appending Tor configuration to /etc/tor/torrc (if missing)...")
    try:
        # Read existing torrc and append the marker block only if it's missing
        with open(torrc_path, 'r') as f:
            existing = f.read()

        if torrc_marker not in existing:
            with open(torrc_path, 'a') as f:
                f.write(torrc_content)
            success("Tor configuration appended to /etc/tor/torrc.")
        else:
            info("Tor configuration marker already present; skipping append.")
    except IOError as e:
        error(f"Error modifying torrc: {e}", fatal=True)

    # --- DNS configuration / backup ----------------------------------------
    info("Preparing DNS configuration (resolv.conf)...")
    try:
        if os.path.islink(resolv):
            orig_target = os.readlink(resolv)
            info(f"/etc/resolv.conf is a symlink to {orig_target}; recording and replacing with a plain file.")
            with open(resolv_backup_link, 'w') as f:
                f.write(orig_target)
            os.remove(resolv)
        else:
            if not os.path.exists(resolv_backup):
                shutil.copy(resolv, resolv_backup)
                info(f"Backed up /etc/resolv.conf to {resolv_backup}")
            else:
                info("Existing resolv.conf backup found; will not overwrite.")

        with open(resolv, 'w') as f:
            f.write("nameserver 127.0.0.1\n")
        success("Wrote /etc/resolv.conf -> nameserver 127.0.0.1")
    except IOError as e:
        error(f"Error configuring DNS: {e}", fatal=True)

    # --- Start Tor service -------------------------------------------------
    info("Starting tor service (systemctl start tor)...")
    try:
        subprocess.run(['systemctl', 'start', 'tor'], check=True,
                       stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        success("Tor service started.")
    except subprocess.CalledProcessError:
        error("Failed to start Tor service.", fatal=True)

    # --- Determine Tor user's UID -----------------------------------------
    info("Determining 'tor' user UID for firewall exemptions...")
    try:
        tor_uid = subprocess.run(['id', '-u', 'tor'],
                                 capture_output=True, text=True, check=True).stdout.strip()
        info(f"Using tor UID: {tor_uid}")
    except subprocess.CalledProcessError:
        error("Failed to get Tor UID.", fatal=True)

    # --- Prepare iptables (IPv4) script -----------------------------------
    # Build the iptables script as a heredoc string and then execute in bash.
    # Rules explanation:
    # - Flush existing rules to start from a clean state.
    # - Allow tor user's traffic through (RETURN).
    # - Redirect DNS (both UDP and TCP port 53) to Tor's DNSPort (53 -> 53 local).
    # - Exclude RFC1918 networks and loopback from redirection.
    # - Redirect TCP SYN packets to TransPort so outgoing TCP goes through Tor.
    # - Accept established connections.
    # - Default reject for OUTPUT to ensure non-exempt traffic is blocked.
    iptables_script = f"""
iptables -F
iptables -t nat -F
iptables -t nat -A OUTPUT -m owner --uid-owner {tor_uid} -j RETURN
iptables -t nat -A OUTPUT -p udp --dport 53 -j REDIRECT --to-ports 53
iptables -t nat -A OUTPUT -p tcp --dport 53 -j REDIRECT --to-ports 53
iptables -t nat -A OUTPUT -d 192.168.1.0/24 -j RETURN
iptables -t nat -A OUTPUT -d 192.168.0.0/24 -j RETURN  
iptables -t nat -A OUTPUT -d 127.0.0.0/8 -j RETURN
iptables -t nat -A OUTPUT -p tcp --syn -j REDIRECT --to-ports 9040
iptables -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
iptables -A OUTPUT -d 192.168.1.0/24 -j ACCEPT
iptables -A OUTPUT -d 192.168.0.0/24 -j ACCEPT
iptables -A OUTPUT -d 127.0.0.0/8 -j ACCEPT
iptables -A OUTPUT -m owner --uid-owner {tor_uid} -j ACCEPT
iptables -A OUTPUT -j REJECT
"""

    # --- Prepare ip6tables (IPv6) script ----------------------------------
    # Many systems may not have IPv6 configured; this script attempts to apply
    # IPv6 equivalents. Failure to apply is non-fatal but emits a warning.
    ip6tables_script = f"""
ip6tables -F
ip6tables -t nat -F
ip6tables -t nat -A OUTPUT -m owner --uid-owner {tor_uid} -j RETURN
ip6tables -t nat -A OUTPUT -p udp --dport 53 -j REDIRECT --to-ports 53
ip6tables -t nat -A OUTPUT -p tcp --dport 53 -j REDIRECT --to-ports 53
ip6tables -t nat -A OUTPUT -d ::1/128 -j RETURN
ip6tables -t nat -A OUTPUT -d fc00::/7 -j RETURN
ip6tables -t nat -A OUTPUT -p tcp --syn -j REDIRECT --to-ports 9040
ip6tables -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
ip6tables -A OUTPUT -d ::1/128 -j ACCEPT
ip6tables -A OUTPUT -d fc00::/7 -j ACCEPT
ip6tables -A OUTPUT -m owner --uid-owner {tor_uid} -j ACCEPT
ip6tables -A OUTPUT -j REJECT
"""

    # --- Apply iptables rules ---------------------------------------------
    info("Applying IPv4 iptables rules to route traffic through Tor...")
    try:
        subprocess.run(['bash', '-c', iptables_script], check=True,
                       stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        success("IPv4 iptables rules applied.")
    except subprocess.CalledProcessError:
        error("Failed to apply IPv4 iptables rules.", fatal=True)

    info("Applying IPv6 ip6tables rules (may be unsupported on some systems)...")
    try:
        subprocess.run(['bash', '-c', ip6tables_script], check=True,
                       stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        success("IPv6 ip6tables rules applied.")
    except subprocess.CalledProcessError:
        warn("Failed to apply IPv6 iptables rules. IPv6 traffic may not be routed through Tor.")

    # --- Final status messages --------------------------------------------
    success(f"TorGhost started. Current IP: {get_ip()}")
    info("Note: All DNS (IPv4 & IPv6) and TCP traffic routed through Tor.")
    info("Run 'sudo torghost stop' to revert all changes.")

def stop_torghost():
    """
    Revert changes made by start_torghost:
    1. Flush IPv4 and IPv6 firewall rules (reset policies to ACCEPT).
    2. Stop the Tor service.
    3. Remove the TorGhost block from torrc.
    4. Restore backed-up /etc/resolv.conf if present.
    """

    # --- Flush IPv4 iptables ----------------------------------------------
    info("Flushing IPv4 iptables and restoring default ACCEPT policies...")
    try:
        subprocess.run(['bash', '-c', """
iptables -P INPUT ACCEPT
iptables -P FORWARD ACCEPT
iptables -P OUTPUT ACCEPT
iptables -t nat -F
iptables -t mangle -F
iptables -F
iptables -X
"""], check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        success("IPv4 firewall flushed.")
    except subprocess.CalledProcessError:
        warn("Failed to flush IPv4 iptables; manual intervention may be required.")

    # --- Flush IPv6 ip6tables --------------------------------------------
    info("Flushing IPv6 ip6tables and restoring default ACCEPT policies...")
    try:
        subprocess.run(['bash', '-c', """
ip6tables -P INPUT ACCEPT
ip6tables -P FORWARD ACCEPT
ip6tables -P OUTPUT ACCEPT
ip6tables -t nat -F
ip6tables -t mangle -F
ip6tables -F
ip6tables -X
"""], check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        success("IPv6 firewall flushed.")
    except subprocess.CalledProcessError:
        warn("Failed to flush IPv6 iptables; manual intervention may be required.")

    # --- Stop Tor service -------------------------------------------------
    info("Stopping Tor service (systemctl stop tor)...")
    try:
        subprocess.run(['systemctl', 'stop', 'tor'], check=True,
                       stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        success("Tor service stopped.")
    except subprocess.CalledProcessError:
        warn("Failed to stop Tor service; it may already be stopped or not installed.")

    # --- Clean up torrc ---------------------------------------------------
    info("Cleaning up tor configuration in /etc/tor/torrc...")
    try:
        with open(torrc_path, 'r') as f:
            lines = f.readlines()

        in_block = False
        cleaned_lines = []
        for line in lines:
            if torrc_marker in line:
                in_block = True
                continue
            if in_block and line.strip() == '':
                in_block = False
                continue
            if not in_block:
                cleaned_lines.append(line)

        with open(torrc_path, 'w') as f:
            f.writelines(cleaned_lines)
        success("Removed TorGhost configuration block from torrc.")
    except IOError as e:
        warn(f"Failed to clean torrc: {e}")

    # --- Restore network resolver ----------------------------------------
    info("Restoring original /etc/resolv.conf (or symlink) if backup exists...")
    if os.path.exists(resolv_backup_link):
        try:
            with open(resolv_backup_link, 'r') as f:
                orig_target = f.read().strip()
            if os.path.exists(resolv):
                try:
                    os.remove(resolv)
                except Exception:
                    pass
            os.symlink(orig_target, resolv)
            os.remove(resolv_backup_link)
            success("Restored original resolv.conf symlink.")
        except IOError as e:
            warn(f"Failed to restore symlinked resolv.conf: {e}")
    elif os.path.exists(resolv_backup):
        try:
            shutil.move(resolv_backup, resolv)
            success("Restored backup /etc/resolv.conf.")
        except IOError as e:
            warn(f"Failed to restore resolv.conf: {e}")
    else:
        warn("No resolv.conf backup found. DNS may need manual restoration.")

    # --- Final status messages --------------------------------------------
    success(f"TorGhost stopped. Current IP: {get_ip()}")

def switch_tor():
    """
    Ask the Tor control port for a new circuit (NEWNYM), effectively switching
    the exit node and changing the apparent public IP. Wait a short time for
    the circuit to be established and then report the new IP.
    """
    with Controller.from_port(port=9051) as controller:
        controller.authenticate()
        controller.signal(Signal.NEWNYM)
    # Allow time for the new circuit to be used
    time.sleep(5)
    print(f"{t()} CURRENT IP: {bcolors.GREEN}{get_ip()}{bcolors.ENDC}")


def show_status():
    """
    Show basic status: whether the tor service is active and the current IP.
    This is a non-root operation (only reads state).
    """
    ip = get_ip()
    tor_status = subprocess.run(['systemctl', 'is-active', 'tor'],
                                capture_output=True, text=True).stdout.strip()
    print(f"Tor Status: {tor_status}")
    print(f"Current IP: {ip}")


# --- Main execution flow ----------------------------------------------------
# Install a SIGINT handler to allow graceful exit with Ctrl-C.
signal.signal(signal.SIGINT, sigint_handler)

# Basic CLI parsing. Require a single subcommand.
if len(sys.argv) < 2:
    usage()

command = sys.argv[1].lower()

# For operations that modify system state, ensure running as root.
if command in ['start', 'stop', 'switch']:
    if os.geteuid() != 0:
        print(f"{bcolors.RED}{bcolors.BOLD}You must be root to run this command.{bcolors.ENDC}")
        sys.exit(1)

# Dispatch subcommands to their handlers.
if command == "start":
    logo()
    start_torghost()
elif command == "stop":
    logo()
    stop_torghost()
elif command == "switch":
    switch_tor()
elif command == "status":
    show_status()
else:
    usage()
