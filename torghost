#!/usr/bin/env python3
"""
TorGhost - Clean and Working Version

This script controls system-level configuration to route traffic through Tor.
It must be run as root for actions that modify system services, networking,
and firewall rules.

Detailed comments have been added throughout to explain the purpose of each
section and the reasoning behind key operations.
"""

# --- Standard library imports ------------------------------------------------
# os, sys: file paths, exit, effective UID checks
# subprocess: run system commands (systemctl, iptables, curl, id)
# time: used for timestamps in logging
# signal: capture Ctrl-C / SIGINT to perform a clean shutdown
# shutil: file operations such as copying and moving files (resolv.conf backup)
# socket: used to check if Tor ports are open
import os
import sys
import subprocess
import time
import signal
import shutil
import socket  # added for port checks
import threading  # new: used for check-leak monitor

# --- Third-party dependency check -------------------------------------------
# 'stem' is required to control the Tor process via its control port and to
# request new circuits (NEWNYM). Rather than attempting to auto-install here,
# provide a clear message to the operator if it's missing and exit with guidance.
try:
    from stem import Signal
    from stem.control import Controller
except Exception:
    # Informative guidance for installing the dependency
    print("Required Python package 'stem' is not installed.")
    print("On Arch: sudo pacman -S python-stem")
    print("Or with pip: pip install stem")
    sys.exit(1)


# --- Terminal color helper class --------------------------------------------
# bcolors provides a small, local set of escape sequences to color terminal
# output. Used to make status and error messages easier to spot.
class bcolors:
    BLUE = '\033[94m'
    GREEN = '\033[92m'
    RED = '\033[31m'
    YELLOW = '\033[93m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'

# User feedback helper functions (timestamped, colored)
def info(msg):
    """Informational status message."""
    print(f"{t()} {bcolors.BLUE}{msg}{bcolors.ENDC}")

def success(msg):
    """Success message."""
    print(f"{t()} {bcolors.GREEN}{msg}{bcolors.ENDC}")

def warn(msg):
    """Non-fatal warning."""
    print(f"{t()} {bcolors.YELLOW}{msg}{bcolors.ENDC}")

def error(msg, fatal=False):
    """Error message; if fatal True, exit after printing."""
    print(f"{t()} {bcolors.RED}{msg}{bcolors.ENDC}")
    if fatal:
        sys.exit(1)


# --- Utility functions -------------------------------------------------------
def t():
    """
    Return a compact timestamp string for human-readable logs.

    Example: [14:22:09]
    """
    return "[" + time.strftime('%H:%M:%S') + "]"


def sigint_handler(signum, frame):
    """
    Signal handler for SIGINT (Ctrl-C). Ensures a polite shutdown message
    and exits cleanly by delegating to shutdown().
    """
    print('\nUser interrupt! Shutting down')
    shutdown()


def shutdown():
    """
    Perform any necessary cleanup (if added later) and exit the program.
    Currently prints a timestamped shutdown message and exits.
    """
    print(f"\n{t()} Shutting down torghost")
    sys.exit()


def logo():
    """
    Clear the terminal and print the ASCII banner + version info.
    Kept in a function so it can be reused before interactive usage/help text.
    """
    os.system("clear")
    print(f"{bcolors.RED}{bcolors.BOLD}")
    print(r"""
                                                     
▄▄▄▄▄▄▄▄▄           ▄▄▄▄▄▄▄  ▄▄                      
▀▀▀███▀▀▀          ███▀▀▀▀▀  ██                 ██   
   ███ ▄███▄ ████▄ ███       ████▄ ▄███▄ ▄█▀▀▀ ▀██▀▀ 
   ███ ██ ██ ██ ▀▀ ███  ███▀ ██ ██ ██ ██ ▀███▄  ██   
   ███ ▀███▀ ██    ▀██████▀  ██ ██ ▀███▀ ▄▄▄█▀  ██   
                                                            
    v3.0 - rewritten by nzkritik for Arch Linux
    """)
    print(f"{bcolors.ENDC}")


def usage():
    """
    Print usage instructions and exit. Shows the logo and a basic help message.
    """
    logo()
    print("""
    USAGE:
        sudo torghost start   (start torghost)
        sudo torghost stop    (stop torghost) 
        sudo torghost switch  (switch IP)
        torghost status       (show status)
    """)
    sys.exit()


def get_ip():
    """
    Query an external service (api.ipify.org) to fetch the public IP.

    Strategy updated:
    - If Tor SOCKS (127.0.0.1:9050) is available, prefer SOCKS requests first.
    - Otherwise try direct curl first as before.
    """
    # Ensure curl exists first
    if shutil.which('curl') is None:
        warn("curl not found — cannot query external IP (install curl to enable).")
        return "Unknown"

    # If SocksPort is available use it first (works while routed via Tor)
    if wait_for_port('127.0.0.1', 9050, timeout=1):
        socks_first = True
    else:
        socks_first = False

    def curl_request(args):
        try:
            res = subprocess.run(args, capture_output=True, text=True)
            if res.returncode == 0 and res.stdout.strip():
                return res.stdout.strip()
        except Exception as e:
            warn(f"curl raised exception: {e}")
        return None

    # If SOCKS available try via Tor first
    if socks_first:
        socks_attempts = 5
        for attempt in range(1, socks_attempts + 1):
            info(f"Querying external IP via Tor SOCKS5 attempt {attempt}/{socks_attempts}...")
            ip = curl_request(['curl', '-s', '--socks5-hostname', '127.0.0.1:9050', '--connect-timeout', '5', '--max-time', '15', 'https://api.ipify.org'])
            if ip:
                success(f"External IP detected via Tor: {ip}")
                return ip
            warn(f"Tor SOCKS curl attempt {attempt} failed. Retrying...")
            time.sleep(2)
        # Fall back to direct if socks attempts fail
        info("Falling back to direct HTTP attempts after SOCKS failures.")

    # Direct attempts (short timeouts)
    direct_attempts = 2
    for attempt in range(1, direct_attempts + 1):
        info(f"Querying external IP (direct) attempt {attempt}/{direct_attempts}...")
        ip = curl_request(['curl', '-s', '--connect-timeout', '5', '--max-time', '10', 'https://api.ipify.org'])
        if ip:
            success(f"External IP detected (direct): {ip}")
            return ip
        warn(f"Direct curl attempt {attempt} failed.")
        time.sleep(1)

    # If we didn't try socks-first earlier, attempt SOCKS now as a last resort
    if not socks_first:
        socks_attempts = 3
        for attempt in range(1, socks_attempts + 1):
            info(f"Querying external IP via Tor SOCKS5 attempt {attempt}/{socks_attempts}...")
            ip = curl_request(['curl', '-s', '--socks5-hostname', '127.0.0.1:9050', '--connect-timeout', '5', '--max-time', '15', 'https://api.ipify.org'])
            if ip:
                success(f"External IP detected via Tor: {ip}")
                return ip
            warn(f"Tor SOCKS curl attempt {attempt} failed.")
            time.sleep(2)

    warn("Unable to determine external IP after multiple attempts; returning 'Unknown'.")
    return "Unknown"


# New helper: wait for a TCP port to be reachable on host
def wait_for_port(host, port, timeout=60, interval=1):
    """
    Wait until a TCP port is accepting connections.
    Returns True if the port is reachable within timeout, False otherwise.
    """
    deadline = time.time() + timeout
    while time.time() < deadline:
        try:
            with socket.create_connection((host, port), timeout=2):
                return True
        except Exception:
            time.sleep(interval)
    return False


# New IPv6 handling helpers
def disable_ipv6():
    """
    Save current IPv6 sysctl values and set system-wide IPv6 disable to 1.
    Writes previous values to IPV6_BACKUP_FILE for restoration later.
    """
    info("Disabling IPv6 system-wide for duration of TorGhost...")
    keys = ['net.ipv6.conf.all.disable_ipv6', 'net.ipv6.conf.default.disable_ipv6']
    prev = {}
    for key in keys:
        try:
            res = subprocess.run(['sysctl', '-n', key], capture_output=True, text=True)
            if res.returncode == 0:
                prev[key] = res.stdout.strip()
            else:
                prev[key] = '0'
        except Exception:
            prev[key] = '0'
    # Save previous values
    try:
        with open(IPV6_BACKUP_FILE, 'w') as f:
            for k, v in prev.items():
                f.write(f"{k}={v}\n")
    except Exception as e:
        warn(f"Could not write IPv6 backup file: {e}")
    # Disable ipv6
    for key in keys:
        try:
            subprocess.run(['sysctl', '-w', f'{key}=1'], check=False)
        except Exception as e:
            warn(f"Failed to set {key}=1: {e}")
    success("IPv6 disabled (sysctl values set).")

def restore_ipv6():
    """
    Restore IPv6 sysctl values from IPV6_BACKUP_FILE if present.
    """
    if not os.path.exists(IPV6_BACKUP_FILE):
        info("No IPv6 backup file found; skipping IPv6 restore.")
        return
    try:
        with open(IPV6_BACKUP_FILE, 'r') as f:
            for line in f:
                if '=' in line:
                    key, val = line.strip().split('=', 1)
                    try:
                        subprocess.run(['sysctl', '-w', f'{key}={val}'], check=False)
                    except Exception as e:
                        warn(f"Failed to restore {key}={val}: {e}")
        os.remove(IPV6_BACKUP_FILE)
        success("IPv6 sysctl values restored from backup.")
    except Exception as e:
        warn(f"Failed to restore IPv6 settings: {e}")


# --- Core operational functions ----------------------------------------------
def start_torghost():
    """
    Start TorGhost by:
    1. Appending a Tor configuration block (torrc) if not already present.
    2. Backing up and modifying /etc/resolv.conf to point DNS to localhost.
    3. Starting the Tor systemd service.
    4. Determining the 'tor' user UID for firewall exclusions.
    5. Applying iptables and ip6tables rules to route DNS and TCP traffic
       through Tor while excluding local/private networks and the tor user.
    """

    # --- torrc configuration ------------------------------------------------
    # We write a small configuration block to ensure Tor listens on the
    # ports we expect (TransPort 9040, DNSPort 53, ControlPort 9051) and
    # that VirtualAddrNetwork/AutomapHostsOnResolve are enabled.
    torrc_path = '/etc/tor/torrc'
    torrc_marker = '## TorGhost Configuration'
    torrc_content = f"""
{torrc_marker}
VirtualAddrNetwork 10.0.0.0/10
AutomapHostsOnResolve 1
TransPort 9040
DNSPort 53
ControlPort 9051
"""

    info("Appending Tor configuration to /etc/tor/torrc (if missing)...")
    try:
        # Read existing torrc and append the marker block only if it's missing
        with open(torrc_path, 'r') as f:
            existing = f.read()

        if torrc_marker not in existing:
            with open(torrc_path, 'a') as f:
                f.write(torrc_content)
            success("Tor configuration appended to /etc/tor/torrc.")
        else:
            info("Tor configuration marker already present; skipping append.")
    except IOError as e:
        error(f"Error modifying torrc: {e}", fatal=True)

    # --- Start Tor service and wait for it to be ready --------------------
    info("Starting tor service (systemctl start tor)...")
    try:
        subprocess.run(['systemctl', 'start', 'tor'], check=True,
                       stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        success("Tor service start requested.")
        subprocess.run(['systemctl', 'status', 'tor'], check=True)
    except subprocess.CalledProcessError:
        error("Failed to start Tor service.", fatal=True)

    # Wait for Tor control port to be available
    info("Waiting for Tor control port (127.0.0.1:9051) to become available (timeout 60s)...")
    if not wait_for_port('127.0.0.1', 9051, timeout=60):
        error("Tor control port 9051 did not become available in time. Aborting.", fatal=True)
    success("Tor control port is reachable.")

    # Wait for TransPort (9040) to be listening (required for transparent proxying)
    info("Waiting for Tor TransPort (127.0.0.1:9040) to become available (timeout 30s)...")
    if not wait_for_port('127.0.0.1', 9040, timeout=30):
        warn("Tor TransPort 9040 did not appear to be listening yet. Transparent proxying may fail.")
    else:
        success("Tor TransPort is reachable.")

    # --- DNS configuration / backup (moved until Tor is up) ----------------
    # Define resolv paths used for backup/restore and replacement.
    resolv = '/etc/resolv.conf'
    resolv_backup = '/etc/resolv.conf.bak-torghost'
    resolv_backup_link = '/etc/resolv.conf.bak-torghost-link'

    info("Preparing DNS configuration (resolv.conf) — backing up and pointing to Tor DNSPort...")
    try:
        if os.path.islink(resolv):
            orig_target = os.readlink(resolv)
            info(f"/etc/resolv.conf is a symlink to {orig_target}; recording and replacing with a plain file.")
            with open(resolv_backup_link, 'w') as f:
                f.write(orig_target)
            os.remove(resolv)
        else:
            if not os.path.exists(resolv_backup):
                shutil.copy(resolv, resolv_backup)
                info(f"Backed up /etc/resolv.conf to {resolv_backup}")
            else:
                info("Existing resolv.conf backup found; will not overwrite.")

        # Write a plain resolv.conf pointing to the local Tor DNSPort
        with open(resolv, 'w') as f:
            f.write("nameserver 127.0.0.1\n")
        success("Wrote /etc/resolv.conf -> nameserver 127.0.0.1")
    except IOError as e:
        error(f"Error configuring DNS: {e}", fatal=True)

    # --- Determine Tor user's UID -----------------------------------------
    info("Determining 'tor' user UID for firewall exemptions...")
    try:
        tor_uid = subprocess.run(['id', '-u', 'tor'],
                                 capture_output=True, text=True, check=True).stdout.strip()
        info(f"Using tor UID: {tor_uid}")
    except subprocess.CalledProcessError:
        error("Failed to get Tor UID.", fatal=True)

    # --- Prepare iptables (IPv4) script -----------------------------------
    # Build the iptables script as a heredoc string and then execute in bash.
    # Updated to:
    # - Exclude full RFC1918 ranges (10/8, 172.16/12, 192.168/16), carrier-grade NAT (100.64/10),
    #   link-local (169.254/16) and multicast (224/4) from redirection.
    # - Exempt the tor user's traffic to avoid loops.
    # - Redirect UDP/TCP port 53 (DNS) to Tor DNSPort and redirect TCP SYN to TransPort.
    # - In filter table accept established/related, tor user, and local networks, then REJECT all else.
    iptables_script = f"""
iptables -F
iptables -t nat -F

# Don't redirect traffic generated by the tor user (avoid loops)
iptables -t nat -A OUTPUT -m owner --uid-owner {tor_uid} -j RETURN

# Exclude local / private / link-local / multicast destinations from redirection
iptables -t nat -A OUTPUT -d 127.0.0.0/8 -j RETURN
iptables -t nat -A OUTPUT -d 10.0.0.0/8 -j RETURN
iptables -t nat -A OUTPUT -d 172.16.0.0/12 -j RETURN
iptables -t nat -A OUTPUT -d 192.168.0.0/16 -j RETURN
iptables -t nat -A OUTPUT -d 100.64.0.0/10 -j RETURN
iptables -t nat -A OUTPUT -d 169.254.0.0/16 -j RETURN
iptables -t nat -A OUTPUT -d 224.0.0.0/4 -j RETURN

# Redirect DNS (UDP & TCP) to Tor DNSPort
iptables -t nat -A OUTPUT -p udp --dport 53 -j REDIRECT --to-ports 53
iptables -t nat -A OUTPUT -p tcp --dport 53 -j REDIRECT --to-ports 53

# Redirect outgoing TCP connections to Tor TransPort
iptables -t nat -A OUTPUT -p tcp --syn -j REDIRECT --to-ports 9040

# Filter rules: allow established and exempted traffic, block the rest
iptables -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT

# Allow local/network management and loopback destinations
iptables -A OUTPUT -d 127.0.0.0/8 -j ACCEPT
iptables -A OUTPUT -d 10.0.0.0/8 -j ACCEPT
iptables -A OUTPUT -d 172.16.0.0/12 -j ACCEPT
iptables -A OUTPUT -d 192.168.0.0/16 -j ACCEPT
iptables -A OUTPUT -d 100.64.0.0/10 -j ACCEPT
iptables -A OUTPUT -d 169.254.0.0/16 -j ACCEPT

# Allow traffic from the tor user
iptables -A OUTPUT -m owner --uid-owner {tor_uid} -j ACCEPT

# Reject everything else (makes sure non-exempt IPv4 traffic must go via Tor)
iptables -A OUTPUT -j REJECT
"""

    # --- Prepare ip6tables (IPv6) script ----------------------------------
    # Many systems may not have IPv6 configured; this script attempts to apply
    # IPv6 equivalents. Failure to apply is non-fatal but emits a warning.
    # For troubleshooting IPv6 is currently disabled — comment out the script.
    # ip6tables_script = f"""
    # ip6tables -F
    # ip6tables -t nat -F
    # ip6tables -t nat -A OUTPUT -m owner --uid-owner {tor_uid} -j RETURN
    # ip6tables -t nat -A OUTPUT -p udp --dport 53 -j REDIRECT --to-ports 53
    # ip6tables -t nat -A OUTPUT -p tcp --dport 53 -j REDIRECT --to-ports 53
    # ip6tables -t nat -A OUTPUT -d ::1/128 -j RETURN
    # ip6tables -t nat -A OUTPUT -d fc00::/7 -j RETURN
    # ip6tables -t nat -A OUTPUT -p tcp --syn -j REDIRECT --to-ports 9040
    # ip6tables -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
    # ip6tables -A OUTPUT -d ::1/128 -j ACCEPT
    # ip6tables -A OUTPUT -d fc00::/7 -j ACCEPT
    # ip6tables -A OUTPUT -m owner --uid-owner {tor_uid} -j ACCEPT
    # ip6tables -A OUTPUT -j REJECT
    # """

    # --- Apply iptables rules ---------------------------------------------
    info("Applying IPv4 iptables rules to route traffic through Tor...")
    try:
        subprocess.run(['bash', '-c', iptables_script], check=True,
                       stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        success("IPv4 iptables rules applied.")
    except subprocess.CalledProcessError:
        error("Failed to apply IPv4 iptables rules.", fatal=True)

    # Install additional DNS hardening rules (defense-in-depth)
    try:
        tighten_dns_rules(tor_uid)
    except Exception as e:
        warn(f"Could not apply DNS hardening rules: {e}")

    # IPv6 handling disabled for troubleshooting.
    #info("IPv6 ip6tables application is currently disabled for troubleshooting")

    # Small delay to allow Tor circuits to bootstrap and for NAT to stabilize
    #info("Waiting a few seconds for Tor to bootstrap circuits...")
    #time.sleep(5)

    # --- Final status messages --------------------------------------------
    success(f"TorGhost started. Current IP: {get_ip()}")
    info("Note: All DNS (IPv4 & IPv6) and TCP traffic routed through Tor.")
    info("Run 'sudo torghost stop' to revert all changes.")

def stop_torghost():
    """
    Revert changes made by start_torghost:
    1. Flush IPv4 and IPv6 firewall rules (reset policies to ACCEPT).
    2. Stop the Tor service.
    3. Remove the TorGhost block from torrc.
    4. Restore backed-up /etc/resolv.conf if present.
    """

    # --- Flush IPv4 iptables ----------------------------------------------
    info("Flushing IPv4 iptables and restoring default ACCEPT policies...")
    try:
        subprocess.run(['bash', '-c', """
iptables -P INPUT ACCEPT
iptables -P FORWARD ACCEPT
iptables -P OUTPUT ACCEPT
iptables -t nat -F
iptables -t mangle -F
iptables -F
iptables -X
"""], check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        success("IPv4 firewall flushed.")
    except subprocess.CalledProcessError:
        warn("Failed to flush IPv4 iptables; manual intervention may be required.")

    # --- Flush IPv6 ip6tables --------------------------------------------
    # IPv6 flushing is disabled while troubleshooting to avoid interfering
    # with current diagnostics. Uncomment the block below to re-enable.
    # info("Flushing IPv6 ip6tables and restoring default ACCEPT policies...")
    # try:
    #     subprocess.run(['bash', '-c', """
    # ip6tables -P INPUT ACCEPT
    # ip6tables -P FORWARD ACCEPT
    # ip6tables -P OUTPUT ACCEPT
    # ip6tables -t nat -F
    # ip6tables -t mangle -F
    # ip6tables -F
    # ip6tables -X
    # """], check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    #     success("IPv6 firewall flushed.")
    # except subprocess.CalledProcessError:
    #     warn("Failed to flush IPv6 iptables; manual intervention may be required.")
    info("IPv6 ip6tables flush is currently disabled for troubleshooting.")

    # --- Stop Tor service -------------------------------------------------
    info("Stopping Tor service (systemctl stop tor)...")
    try:
        subprocess.run(['systemctl', 'stop', 'tor'], check=True,
                       stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        success("Tor service stopped.")
    except subprocess.CalledProcessError:
        warn("Failed to stop Tor service; it may already be stopped or not installed.")

    # --- Clean up torrc ---------------------------------------------------
    # Ensure torrc path/marker are defined (use module constants)
    torrc_path = TORRC_PATH
    torrc_marker = TORRC_MARKER

    info("Cleaning up tor configuration in /etc/tor/torrc...")
    try:
        with open(torrc_path, 'r') as f:
            lines = f.readlines()

        in_block = False
        cleaned_lines = []
        for line in lines:
            if torrc_marker in line:
                in_block = True
                continue
            if in_block and line.strip() == '':
                in_block = False
                continue
            if not in_block:
                cleaned_lines.append(line)

        with open(torrc_path, 'w') as f:
            f.writelines(cleaned_lines)
        success("Removed TorGhost configuration block from torrc.")
    except IOError as e:
        warn(f"Failed to clean torrc: {e}")

    # --- Restore network resolver ----------------------------------------
    # Define resolv paths used for backup/restore and restoration steps.
    resolv = '/etc/resolv.conf'
    resolv_backup = '/etc/resolv.conf.bak-torghost'
    resolv_backup_link = '/etc/resolv.conf.bak-torghost-link'

    info("Restoring original /etc/resolv.conf (or symlink) if backup exists...")
    if os.path.exists(resolv_backup_link):
        try:
            with open(resolv_backup_link, 'r') as f:
                orig_target = f.read().strip()
            if os.path.exists(resolv):
                try:
                    os.remove(resolv)
                except Exception:
                    pass
            os.symlink(orig_target, resolv)
            os.remove(resolv_backup_link)
            success("Restored original resolv.conf symlink.")
        except IOError as e:
            warn(f"Failed to restore symlinked resolv.conf: {e}")
    elif os.path.exists(resolv_backup):
        try:
            shutil.move(resolv_backup, resolv)
            success("Restored backup /etc/resolv.conf.")
        except IOError as e:
            warn(f"Failed to restore resolv.conf: {e}")
    else:
        warn("No resolv.conf backup found. DNS may need manual restoration.")

    # --- Remove IPv6 blocking rules and restore default IPv6 policies
    info("Removing IPv6 blocking rules and restoring policies...")
    try:
        subprocess.run(['bash', '-c', 'ip6tables -F || true'], check=False)
        subprocess.run(['bash', '-c', 'ip6tables -P OUTPUT ACCEPT || true'], check=False)
        success("IPv6 ip6tables rules cleared and OUTPUT policy set to ACCEPT.")
    except Exception as e:
        warn(f"Failed to clear ip6tables rules: {e}")

    # --- Restore IPv6 sysctl settings (if changed) ------------------------
    try:
        restore_ipv6()
    except Exception as e:
        warn(f"IPv6 restore step failed: {e}")

    # --- Final status messages --------------------------------------------
    success(f"TorGhost stopped. Current IP: {get_ip()}")

def switch_tor():
    """
    Ask the Tor control port for a new circuit (NEWNYM), effectively switching
    the exit node and changing the apparent public IP. Wait a short time for
    the circuit to be established and then report the new IP.
    """
    with Controller.from_port(port=9051) as controller:
        controller.authenticate()
        controller.signal(Signal.NEWNYM)
    # Allow time for the new circuit to be used
    time.sleep(5)
    print(f"{t()} CURRENT IP: {bcolors.GREEN}{get_ip()}{bcolors.ENDC}")


def show_status():
    """
    Show basic status: whether the tor service is active and the current IP.
    This is a non-root operation (only reads state).
    """
    ip = get_ip()
    tor_status = subprocess.run(['systemctl', 'is-active', 'tor'],
                                capture_output=True, text=True).stdout.strip()
    print(f"Tor Status: {tor_status}")
    print(f"Current IP: {ip}")


def tighten_dns_rules(tor_uid):
	"""
	Add extra filter rules to prevent any non-tor user from sending DNS (UDP/TCP 53)
	directly to the network. These are defense-in-depth: the nat redirect should
	catch DNS, but this prevents escapes (and helps detect misbehavior).
	"""
	info("Installing additional DNS hardening rules (filter table)...")
	try:
		# UDP 53: reject packets from processes not running as tor (IPv4)
		subprocess.run(['bash', '-c',
			f'iptables -C OUTPUT -p udp --dport 53 -m owner ! --uid-owner {tor_uid} -j REJECT >/dev/null 2>&1 || '
			f'iptables -I OUTPUT 1 -p udp --dport 53 -m owner ! --uid-owner {tor_uid} -j REJECT'
		], check=False)
		# TCP 53: same for TCP DNS (IPv4)
		subprocess.run(['bash', '-c',
			f'iptables -C OUTPUT -p tcp --dport 53 -m owner ! --uid-owner {tor_uid} -j REJECT >/dev/null 2>&1 || '
			f'iptables -I OUTPUT 1 -p tcp --dport 53 -m owner ! --uid-owner {tor_uid} -j REJECT'
		], check=False)

		# IPv6 DNS hardening: reject non-tor user IPv6 DNS (UDP & TCP 53)
		subprocess.run(['bash', '-c',
			f'ip6tables -C OUTPUT -p udp --dport 53 -m owner ! --uid-owner {tor_uid} -j REJECT >/dev/null 2>&1 || '
			f'ip6tables -I OUTPUT 1 -p udp --dport 53 -m owner ! --uid-owner {tor_uid} -j REJECT'
		], check=False)
		subprocess.run(['bash', '-c',
			f'ip6tables -C OUTPUT -p tcp --dport 53 -m owner ! --uid-owner {tor_uid} -j REJECT >/dev/null 2>&1 || '
			f'ip6tables -I OUTPUT 1 -p tcp --dport 53 -m owner ! --uid-owner {tor_uid} -j REJECT'
		], check=False)

		success("DNS hardening rules installed (IPv4 & IPv6).")
	except Exception as e:
		warn(f"Failed to install DNS hardening rules: {e}")

# New: apply strict IPv6 block (allow loopback/local/tor user only)
def apply_ipv6_block(tor_uid):
	"""
	Install ip6tables rules to block all outbound IPv6 traffic except:
	- loopback (::1)
	- link-local fe80::/10
	- unique-local fc00::/7
	- multicast ff00::/8
	- traffic from the tor user (avoid loops)
	"""
	info("Applying strict IPv6 outbound block (ip6tables)...")
	try:
		# flush and set default DROP for OUTPUT, but allow critical exceptions
		commands = [
			"ip6tables -F",
			"ip6tables -t raw -F || true",
			"ip6tables -P OUTPUT DROP",
			"ip6tables -A OUTPUT -o lo -j ACCEPT",
			f"ip6tables -A OUTPUT -m owner --uid-owner {tor_uid} -j ACCEPT",
			"ip6tables -A OUTPUT -d ::1/128 -j ACCEPT",
			"ip6tables -A OUTPUT -d fe80::/10 -j ACCEPT",
			"ip6tables -A OUTPUT -d fc00::/7 -j ACCEPT",
			"ip6tables -A OUTPUT -d ff00::/8 -j ACCEPT",
			# allow neighbor discovery to link-local if needed
			"ip6tables -A OUTPUT -p icmpv6 -j ACCEPT"
		]
		for cmd in commands:
			subprocess.run(['bash', '-c', cmd], check=False, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
		success("IPv6 blocking rules applied.")
	except Exception as e:
		warn(f"Failed to apply IPv6 block rules: {e}")


def dns_leak_check(duration=6):
	"""
	Quick DNS leak detection:
	- If tcpdump is available, run it for `duration` seconds and look for
	  any UDP/53 packets not to/from 127.0.0.1 (IPv4) or ::1 (IPv6).
	- If tcpdump is not available, examine iptables nat OUTPUT counters as a hint.
	Returns True if a leak was observed, False otherwise.
	"""
	info("Starting DNS leak check...")
	tcpdump_path = shutil.which('tcpdump')
	if tcpdump_path:
		info(f"Using tcpdump to monitor DNS on all interfaces for {duration} seconds...")
		try:
			# check IPv4 DNS leaks
			cmd_v4 = ['timeout', str(duration), 'tcpdump', '-n', '-i', 'any', 'udp', 'port', '53', 'and', 'not', 'host', '127.0.0.1', '-c', '1']
			proc_v4 = subprocess.run(cmd_v4, capture_output=True, text=True)
			out_v4 = proc_v4.stdout.strip() + proc_v4.stderr.strip()
			if proc_v4.returncode == 0 and out_v4:
				warn("DNS leak detected (IPv4): observed UDP/53 traffic to non-local addresses:")
				print(out_v4)
				return True
			# check IPv6 DNS leaks
			cmd_v6 = ['timeout', str(duration), 'tcpdump', '-n', '-i', 'any', 'ip6', 'and', 'udp', 'port', '53', 'and', 'not', 'host', '::1', '-c', '1']
			proc_v6 = subprocess.run(cmd_v6, capture_output=True, text=True)
			out_v6 = proc_v6.stdout.strip() + proc_v6.stderr.strip()
			if proc_v6.returncode == 0 and out_v6:
				warn("DNS leak detected (IPv6): observed UDP/53 traffic to non-local IPv6 addresses:")
				print(out_v6)
				return True
			success("No non-local DNS packets observed during capture windows.")
			return False
		except Exception as e:
			warn(f"tcpdump monitoring failed: {e}")
			return False
	else:
		info("tcpdump not found. Checking iptables nat OUTPUT counters as a heuristic...")
		try:
			nat = subprocess.run(['bash', '-c', 'iptables -t nat -L OUTPUT -v -n'], capture_output=True, text=True)
			print(nat.stdout)
			info("If nat OUTPUT shows zero hits for the DNS redirect rule, DNS may not be redirected.")
			# also show ip6tables OUTPUT rules as heuristic
			ip6 = subprocess.run(['bash', '-c', 'ip6tables -L OUTPUT -v -n'], capture_output=True, text=True)
			print(ip6.stdout)
			return False
		except Exception as e:
			warn(f"Failed to inspect iptables: {e}")
			return False

# New: continuous monitor mode for leak checking
def monitor_leaks(interval=10):
	"""
	Continuously run dns_leak_check() every `interval` seconds.
	User may type 'q' + Enter to quit, or press Ctrl-C.
	"""
	info(f"Entering continuous leak-monitor mode (interval {interval}s).")
	info("Press 'q' then Enter to quit, or Ctrl-C to exit.")
	stop_event = threading.Event()

	def input_watcher():
		# Blocking read on stdin in a thread; sets stop_event when 'q' received.
		try:
			while not stop_event.is_set():
				line = sys.stdin.readline()
				if not line:
					# EOF or no input; small sleep to avoid busy loop
					time.sleep(0.1)
					continue
				if line.strip().lower() == 'q':
					stop_event.set()
					break
		except Exception:
			stop_event.set()

	watcher = threading.Thread(target=input_watcher, daemon=True)
	watcher.start()

	try:
		while not stop_event.is_set():
			leak = dns_leak_check(duration=6)
			if leak:
				warn("Leak detected during monitoring cycle.")
			else:
				success("No leak detected in this cycle.")
			# wait interval seconds but exit early if stop_event set
			for _ in range(int(interval)):
				if stop_event.is_set():
					break
				time.sleep(1)
	except KeyboardInterrupt:
		info("Interrupted by user (Ctrl-C). Exiting monitor.")
		stop_event.set()

	# Ensure watcher thread will finish
	stop_event.set()
	watcher.join(timeout=1)
	info("Leak monitor stopped. Returning to shell.")

# --- Constants -------------------------------------------------------------
# Centralize tor configuration path and marker so all functions can reference them
TORRC_PATH = '/etc/tor/torrc'
TORRC_MARKER = '## TorGhost Configuration'
IPV6_BACKUP_FILE = '/etc/tor/torghost-ipv6-backup'

# --- Main execution flow ----------------------------------------------------
# Install a SIGINT handler to allow graceful exit with Ctrl-C.
signal.signal(signal.SIGINT, sigint_handler)

# Basic CLI parsing. Require a single subcommand.
if len(sys.argv) < 2:
    usage()
    show_status()

command = sys.argv[1].lower()

# For operations that modify system state, ensure running as root.
if command in ['start', 'stop', 'switch']:
    if os.geteuid() != 0:
        print(f"{bcolors.RED}{bcolors.BOLD}You must be root to run this command.{bcolors.ENDC}")
        sys.exit(1)

# Dispatch subcommands to their handlers.
if command == "start":
    logo()
    start_torghost()
elif command == "stop":
    logo()
    stop_torghost()
elif command == "switch":
    switch_tor()
elif command == "status":
    show_status()
elif command == "check-leak":
    # Continuous leak monitoring mode
    # Optional: accept second CLI argument as interval in seconds
    interval = 10
    if len(sys.argv) >= 3:
        try:
            interval = int(sys.argv[2])
        except Exception:
            warn("Invalid interval; using default 10s.")
    monitor_leaks(interval=interval)
else:
    usage()
