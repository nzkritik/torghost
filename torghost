#!/usr/bin/env python3
"""
TorGhost - Clean and Working Version
"""

import os
import sys
import subprocess

# Check if running as sudo
if os.geteuid() != 0:
    print("This script requires sudo privileges.")
    os.execvp('sudo', ['sudo', sys.executable] + sys.argv)

# Venv and dependency management
venv_dir = os.path.join(os.path.expanduser('~'), '.venv')
if not os.path.exists(venv_dir):
    print(f"Creating virtual environment in {venv_dir}...")
    try:
        subprocess.run([sys.executable, '-m', 'venv', venv_dir], check=True)
    except subprocess.CalledProcessError:
        print("Failed to create virtual environment. Please ensure the 'venv' module is available.")
        sys.exit(1)

venv_python = os.path.join(venv_dir, 'bin', 'python')
if sys.executable != os.path.abspath(venv_python):
    print("Relaunching in virtual environment...")
    os.execv(venv_python, [venv_python] + sys.argv)

# The script now runs inside the venv. Deactivation is not needed;
# when the script exits, the process ends, and the parent shell is unaffected.

# Install/Upgrade dependencies
try:
    subprocess.run(
        [sys.executable, '-m', 'pip', 'install', '--upgrade', 'stem'], 
        check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL
    )
except subprocess.CalledProcessError:
    print("Failed to install dependencies. Please check your internet connection and pip configuration.")
    sys.exit(1)

import time
import signal
import shutil
from stem import Signal
from stem.control import Controller


class bcolors:
    BLUE = '\033[94m'
    GREEN = '\033[92m'
    RED = '\033[31m'
    YELLOW = '\033[93m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'


def t():
    return "[" + time.strftime('%H:%M:%S') + "]"


def sigint_handler(signum, frame):
    print('\nUser interrupt! Shutting down')
    shutdown()


def shutdown():
    print(f"\n{t()} Shutting down torghost")
    sys.exit()


def logo():
    os.system("clear")
    print(f"{bcolors.RED}{bcolors.BOLD}")
    print(r"""
                                                     
▄▄▄▄▄▄▄▄▄           ▄▄▄▄▄▄▄  ▄▄                      
▀▀▀███▀▀▀          ███▀▀▀▀▀  ██                 ██   
   ███ ▄███▄ ████▄ ███       ████▄ ▄███▄ ▄█▀▀▀ ▀██▀▀ 
   ███ ██ ██ ██ ▀▀ ███  ███▀ ██ ██ ██ ██ ▀███▄  ██   
   ███ ▀███▀ ██    ▀██████▀  ██ ██ ▀███▀ ▄▄▄█▀  ██   
                                                            
    v3.0 - rewritten by nzkritik for Arch Linux
    """)
    print(f"{bcolors.ENDC}")


def usage():
    logo()
    print("""
    USAGE:
        sudo torghost start   (start torghost)
        sudo torghost stop    (stop torghost) 
        sudo torghost switch  (switch IP)
        torghost status       (show status)
    """)
    sys.exit()


def get_ip():
    try:
        result = subprocess.run(['curl', '-s', 'https://api.ipify.org'], 
                              capture_output=True, text=True)
        return result.stdout.strip()
    except:
        return "Unknown"


def start_torghost():
    # Configure torrc
    torrc_path = '/etc/tor/torrc'
    torrc_marker = '## TorGhost Configuration'
    torrc_content = f"""
{torrc_marker}
VirtualAddrNetwork 10.0.0.0/10
AutomapHostsOnResolve 1
TransPort 9040
DNSPort 53
ControlPort 9051
"""
    
    try:
        with open(torrc_path, 'r') as f:
            existing = f.read()
        
        # Only append if marker not already present
        if torrc_marker not in existing:
            with open(torrc_path, 'a') as f:
                f.write(torrc_content)
    except IOError as e:
        print(f"{bcolors.RED}Error modifying torrc: {e}{bcolors.ENDC}")
        sys.exit(1)
    
    # Configure DNS - create backup only once
    resolv_backup = '/etc/resolv.conf.bak-torghost'
    try:
        if not os.path.exists(resolv_backup):
            shutil.copy('/etc/resolv.conf', resolv_backup)

        with open('/etc/resolv.conf', 'w') as f:
            f.write("nameserver 127.0.0.1\n")
    except IOError as e:
        print(f"{bcolors.RED}Error configuring DNS: {e}{bcolors.ENDC}")
        sys.exit(1)
    
    # Start services
    try:
        subprocess.run(['systemctl', 'start', 'tor'], check=True, 
                      stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    except subprocess.CalledProcessError:
        print(f"{bcolors.RED}Failed to start Tor service.{bcolors.ENDC}")
        sys.exit(1)
    
    # Setup iptables (IPv4 and IPv6)
    try:
        tor_uid = subprocess.run(['id', '-u', 'tor'], 
                               capture_output=True, text=True, check=True).stdout.strip()
    except subprocess.CalledProcessError:
        print(f"{bcolors.RED}Failed to get Tor UID.{bcolors.ENDC}")
        sys.exit(1)
    
    # IPv4 rules
    iptables_script = f"""
iptables -F
iptables -t nat -F
iptables -t nat -A OUTPUT -m owner --uid-owner {tor_uid} -j RETURN
iptables -t nat -A OUTPUT -p udp --dport 53 -j REDIRECT --to-ports 53
iptables -t nat -A OUTPUT -p tcp --dport 53 -j REDIRECT --to-ports 53
iptables -t nat -A OUTPUT -d 192.168.1.0/24 -j RETURN
iptables -t nat -A OUTPUT -d 192.168.0.0/24 -j RETURN  
iptables -t nat -A OUTPUT -d 127.0.0.0/8 -j RETURN
iptables -t nat -A OUTPUT -p tcp --syn -j REDIRECT --to-ports 9040
iptables -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
iptables -A OUTPUT -d 192.168.1.0/24 -j ACCEPT
iptables -A OUTPUT -d 192.168.0.0/24 -j ACCEPT
iptables -A OUTPUT -d 127.0.0.0/8 -j ACCEPT
iptables -A OUTPUT -m owner --uid-owner {tor_uid} -j ACCEPT
iptables -A OUTPUT -j REJECT
"""
    
    # IPv6 rules
    ip6tables_script = f"""
ip6tables -F
ip6tables -t nat -F
ip6tables -t nat -A OUTPUT -m owner --uid-owner {tor_uid} -j RETURN
ip6tables -t nat -A OUTPUT -p udp --dport 53 -j REDIRECT --to-ports 53
ip6tables -t nat -A OUTPUT -p tcp --dport 53 -j REDIRECT --to-ports 53
ip6tables -t nat -A OUTPUT -d ::1/128 -j RETURN
ip6tables -t nat -A OUTPUT -d fc00::/7 -j RETURN
ip6tables -t nat -A OUTPUT -p tcp --syn -j REDIRECT --to-ports 9040
ip6tables -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
ip6tables -A OUTPUT -d ::1/128 -j ACCEPT
ip6tables -A OUTPUT -d fc00::/7 -j ACCEPT
ip6tables -A OUTPUT -m owner --uid-owner {tor_uid} -j ACCEPT
ip6tables -A OUTPUT -j REJECT
"""
    
    try:
        subprocess.run(['bash', '-c', iptables_script], check=True,
                      stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    except subprocess.CalledProcessError:
        print(f"{bcolors.RED}Failed to apply IPv4 iptables rules.{bcolors.ENDC}")
        sys.exit(1)
    
    try:
        subprocess.run(['bash', '-c', ip6tables_script], check=True,
                      stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    except subprocess.CalledProcessError:
        print(f"{bcolors.YELLOW}Warning: Failed to apply IPv6 iptables rules. IPv6 traffic may not be routed through Tor.{bcolors.ENDC}")
    
    print(f"{t()} CURRENT IP: {bcolors.GREEN}{get_ip()}{bcolors.ENDC}")
    print(f"{t()} {bcolors.GREEN}TorGhost started successfully.{bcolors.ENDC} Your traffic is being routed through Tor.")
    print(f"{t()} {bcolors.YELLOW}Note: All DNS (IPv4 & IPv6) and TCP traffic routed through Tor.{bcolors.ENDC}")
    print(f"{t()} Run 'sudo torghost stop' to revert all changes.")


def stop_torghost():
    # Flush iptables (IPv4 and IPv6)
    try:
        subprocess.run(['bash', '-c', """
iptables -P INPUT ACCEPT
iptables -P FORWARD ACCEPT
iptables -P OUTPUT ACCEPT
iptables -t nat -F
iptables -t mangle -F
iptables -F
iptables -X
"""], check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    except subprocess.CalledProcessError:
        print(f"{bcolors.YELLOW}Warning: Failed to flush IPv4 iptables.{bcolors.ENDC}")
    
    try:
        subprocess.run(['bash', '-c', """
ip6tables -P INPUT ACCEPT
ip6tables -P FORWARD ACCEPT
ip6tables -P OUTPUT ACCEPT
ip6tables -t nat -F
ip6tables -t mangle -F
ip6tables -F
ip6tables -X
"""], check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    except subprocess.CalledProcessError:
        print(f"{bcolors.YELLOW}Warning: Failed to flush IPv6 iptables.{bcolors.ENDC}")
    
    # Stop tor service
    try:
        subprocess.run(['systemctl', 'stop', 'tor'], check=True,
                      stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    except subprocess.CalledProcessError:
        print(f"{bcolors.YELLOW}Warning: Failed to stop Tor service.{bcolors.ENDC}")

    # Clean up torrc
    torrc_path = '/etc/tor/torrc'
    torrc_marker = '## TorGhost Configuration'
    
    try:
        with open(torrc_path, 'r') as f:
            lines = f.readlines()
        
        # Remove lines from marker to next blank line
        in_block = False
        cleaned_lines = []
        for line in lines:
            if torrc_marker in line:
                in_block = True
                continue
            if in_block and line.strip() == '':
                in_block = False
                continue
            if not in_block:
                cleaned_lines.append(line)
        
        with open(torrc_path, 'w') as f:
            f.writelines(cleaned_lines)
    except IOError as e:
        print(f"{bcolors.YELLOW}Warning: Failed to clean torrc: {e}{bcolors.ENDC}")
        
    # Restore network
    resolv_backup = '/etc/resolv.conf.bak-torghost'
    if os.path.exists(resolv_backup):
        try:
            shutil.move(resolv_backup, '/etc/resolv.conf')
        except IOError as e:
            print(f"{bcolors.YELLOW}Warning: Failed to restore resolv.conf: {e}{bcolors.ENDC}")
    else:
        print(f"{bcolors.YELLOW}Warning: Backup resolv.conf not found. DNS may need manual restoration.{bcolors.ENDC}")
        
    print(f"{t()} CURRENT IP: {bcolors.GREEN}{get_ip()}{bcolors.ENDC}")
    print(f"{t()} {bcolors.YELLOW}TorGhost stopped.{bcolors.ENDC} Your traffic is no longer routed through Tor.")


def switch_tor():
    with Controller.from_port(port=9051) as controller:
        controller.authenticate()
        controller.signal(Signal.NEWNYM)
    time.sleep(5)
    print(f"{t()} CURRENT IP: {bcolors.GREEN}{get_ip()}{bcolors.ENDC}")


def show_status():
    ip = get_ip()
    tor_status = subprocess.run(['systemctl', 'is-active', 'tor'], 
                              capture_output=True, text=True).stdout.strip()
    print(f"Tor Status: {tor_status}")
    print(f"Current IP: {ip}")


# Main execution - remove redundant root check
signal.signal(signal.SIGINT, sigint_handler)

if len(sys.argv) < 2:
    usage()

command = sys.argv[1].lower()

if command in ['start', 'stop', 'switch']:
    if os.geteuid() != 0:
        print(f"{bcolors.RED}{bcolors.BOLD}You must be root to run this command.{bcolors.ENDC}")
        sys.exit(1)

if command == "start":
    logo()
    start_torghost()
elif command == "stop":
    logo()
    stop_torghost()
elif command == "switch":
    switch_tor()
elif command == "status":
    show_status()
else:
    usage()
