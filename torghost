#!/usr/bin/env python3
"""
TorGhost - Clean and Working Version

This script controls system-level configuration to route traffic through Tor.
It must be run as root for actions that modify system services, networking,
and firewall rules.

Detailed comments have been added throughout to explain the purpose of each
section and the reasoning behind key operations.
"""

# --- Standard library imports ------------------------------------------------
# os, sys: file paths, exit, effective UID checks
# subprocess: run system commands (systemctl, iptables, curl, id)
# time: used for timestamps in logging
# signal: capture Ctrl-C / SIGINT to perform a clean shutdown
# shutil: file operations such as copying and moving files (resolv.conf backup)
# socket: used to check if Tor ports are open
import os
import sys
import subprocess
import time
import signal
import shutil
import socket  # added for port checks
import threading  # new: used for check-leak monitor
import re  # new: for parsing Tor bootstrap progress

# --- Third-party dependency check -------------------------------------------
# 'stem' is required to control the Tor process via its control port and to
# request new circuits (NEWNYM). Rather than attempting to auto-install here,
# provide a clear message to the operator if it's missing and exit with guidance.
try:
    from stem import Signal
    from stem.control import Controller
except Exception:
    # Informative guidance for installing the dependency
    print("Required Python package 'stem' is not installed.")
    print("On Arch: sudo pacman -S python-stem")
    print("Or with pip: pip install stem")
    sys.exit(1)


# --- Terminal color helper class --------------------------------------------
# bcolors provides a small, local set of escape sequences to color terminal
# output. Used to make status and error messages easier to spot.
class bcolors:
    BLUE = '\033[94m'
    GREEN = '\033[92m'
    RED = '\033[31m'
    YELLOW = '\033[93m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'

# User feedback helper functions (timestamped, colored)
def info(msg):
    """Informational status message."""
    print(f"{t()} {bcolors.BLUE}{msg}{bcolors.ENDC}")

def success(msg):
    """Success message."""
    print(f"{t()} {bcolors.GREEN}{msg}{bcolors.ENDC}")

def warn(msg):
    """Non-fatal warning."""
    print(f"{t()} {bcolors.YELLOW}{msg}{bcolors.ENDC}")

def error(msg, fatal=False):
    """Error message; if fatal True, exit after printing."""
    print(f"{t()} {bcolors.RED}{msg}{bcolors.ENDC}")
    if fatal:
        sys.exit(1)


# --- Utility functions -------------------------------------------------------
def t():
    """
    Return a compact timestamp string for human-readable logs.

    Example: [14:22:09]
    """
    return "[" + time.strftime('%H:%M:%S') + "]"


def sigint_handler(signum, frame):
    """
    Signal handler for SIGINT (Ctrl-C). Ensures a polite shutdown message
    and exits cleanly by delegating to shutdown().
    """
    print('\nUser interrupt! Shutting down')
    shutdown()


def shutdown():
    """
    Perform any necessary cleanup (if added later) and exit the program.
    Currently prints a timestamped shutdown message and exits.
    """
    print(f"\n{t()} Shutting down torghost")
    sys.exit()


def logo():
    """
    Clear the terminal and print the ASCII banner + version info.
    Kept in a function so it can be reused before interactive usage/help text.
    """
    os.system("clear")
    print(f"{bcolors.RED}{bcolors.BOLD}")
    print(r"""
                                                     
▄▄▄▄▄▄▄▄▄           ▄▄▄▄▄▄▄  ▄▄                      
▀▀▀███▀▀▀          ███▀▀▀▀▀  ██                 ██   
   ███ ▄███▄ ████▄ ███       ████▄ ▄███▄ ▄█▀▀▀ ▀██▀▀ 
   ███ ██ ██ ██ ▀▀ ███  ███▀ ██ ██ ██ ██ ▀███▄  ██   
   ███ ▀███▀ ██    ▀██████▀  ██ ██ ▀███▀ ▄▄▄█▀  ██   
                                                            
    v3.0 - rewritten by nzkritik for Arch Linux
    """)
    print(f"{bcolors.ENDC}")


def usage():
    """
    Print usage instructions and exit. Shows the logo and a basic help message.
    """
    logo()
    print("""
    USAGE:
        sudo torghost start   (start torghost)
        sudo torghost stop    (stop torghost) 
        sudo torghost switch  (switch IP)
        torghost status       (show status)
        sudo torghost check-leak [interval_seconds]
            (run continuous DNS leak monitoring; default interval 10s)
    """)
    sys.exit()


def get_ip():
    """
    Query an external service (api.ipify.org) to fetch the public IP.

    Strategy updated:
    - If Tor SOCKS (127.0.0.1:9050) is available, prefer SOCKS requests first.
    - Otherwise try direct curl first as before.
    """
    # Ensure curl exists first
    if shutil.which('curl') is None:
        warn("curl not found — cannot query external IP (install curl to enable).")
        return "Unknown"

    # If SocksPort is available use it first (works while routed via Tor)
    if wait_for_port('127.0.0.1', 9050, timeout=1):
        socks_first = True
    else:
        socks_first = False

    def curl_request(args):
        try:
            res = subprocess.run(args, capture_output=True, text=True)
            if res.returncode == 0 and res.stdout.strip():
                return res.stdout.strip()
        except Exception as e:
            warn(f"curl raised exception: {e}")
        return None

    # If SOCKS available try via Tor first
    if socks_first:
        socks_attempts = 5
        for attempt in range(1, socks_attempts + 1):
            info(f"Querying external IP via Tor SOCKS5 attempt {attempt}/{socks_attempts}...")
            ip = curl_request(['curl', '-s', '--socks5-hostname', '127.0.0.1:9050', '--connect-timeout', '5', '--max-time', '15', 'https://api.ipify.org'])
            if ip:
                success(f"External IP detected via Tor: {ip}")
                return ip
            warn(f"Tor SOCKS curl attempt {attempt} failed. Retrying...")
            time.sleep(2)
        # Fall back to direct if socks attempts fail
        info("Falling back to direct HTTP attempts after SOCKS failures.")

    # Direct attempts (short timeouts)
    direct_attempts = 2
    for attempt in range(1, direct_attempts + 1):
        info(f"Querying external IP (direct) attempt {attempt}/{direct_attempts}...")
        ip = curl_request(['curl', '-s', '--connect-timeout', '5', '--max-time', '10', 'https://api.ipify.org'])
        if ip:
            success(f"External IP detected (direct): {ip}")
            return ip
        warn(f"Direct curl attempt {attempt} failed.")
        time.sleep(1)

    # If we didn't try socks-first earlier, attempt SOCKS now as a last resort
    if not socks_first:
        socks_attempts = 3
        for attempt in range(1, socks_attempts + 1):
            info(f"Querying external IP via Tor SOCKS5 attempt {attempt}/{socks_attempts}...")
            ip = curl_request(['curl', '-s', '--socks5-hostname', '127.0.0.1:9050', '--connect-timeout', '5', '--max-time', '15', 'https://api.ipify.org'])
            if ip:
                success(f"External IP detected via Tor: {ip}")
                return ip
            warn(f"Tor SOCKS curl attempt {attempt} failed.")
            time.sleep(2)

    warn("Unable to determine external IP after multiple attempts; returning 'Unknown'.")
    return "Unknown"


# New helper: wait for a TCP port to be reachable on host
def wait_for_port(host, port, timeout=60, interval=1):
    """
    Wait until a TCP port is accepting connections.
    Returns True if the port is reachable within timeout, False otherwise.
    """
    deadline = time.time() + timeout
    while time.time() < deadline:
        try:
            with socket.create_connection((host, port), timeout=2):
                return True
        except Exception:
            time.sleep(interval)
    return False


# New IPv6 handling helpers
def disable_ipv6():
    """
    Save current IPv6 sysctl values and set system-wide IPv6 disable to 1.
    Writes previous values to IPV6_BACKUP_FILE for restoration later.
    """
    info("Disabling IPv6 system-wide for duration of TorGhost...")
    keys = ['net.ipv6.conf.all.disable_ipv6', 'net.ipv6.conf.default.disable_ipv6']
    prev = {}
    for key in keys:
        try:
            res = subprocess.run(['sysctl', '-n', key], capture_output=True, text=True)
            if res.returncode == 0:
                prev[key] = res.stdout.strip()
            else:
                prev[key] = '0'
        except Exception:
            prev[key] = '0'
    # Save previous values
    try:
        with open(IPV6_BACKUP_FILE, 'w') as f:
            for k, v in prev.items():
                f.write(f"{k}={v}\n")
    except Exception as e:
        warn(f"Could not write IPv6 backup file: {e}")
    # Disable ipv6
    for key in keys:
        try:
            subprocess.run(['sysctl', '-w', f'{key}=1'], check=False)
        except Exception as e:
            warn(f"Failed to set {key}=1: {e}")
    success("IPv6 disabled (sysctl values set).")

def restore_ipv6():
    """
    Restore IPv6 sysctl values from IPV6_BACKUP_FILE if present.
    """
    if not os.path.exists(IPV6_BACKUP_FILE):
        info("No IPv6 backup file found; skipping IPv6 restore.")
        return
    try:
        with open(IPV6_BACKUP_FILE, 'r') as f:
            for line in f:
                if '=' in line:
                    key, val = line.strip().split('=', 1)
                    try:
                        subprocess.run(['sysctl', '-w', f'{key}={val}'], check=False)
                    except Exception as e:
                        warn(f"Failed to restore {key}={val}: {e}")
        os.remove(IPV6_BACKUP_FILE)
        success("IPv6 sysctl values restored from backup.")
    except Exception as e:
        warn(f"Failed to restore IPv6 settings: {e}")

# --- Constants -------------------------------------------------------------
TORRC_PATH = '/etc/tor/torrc'
TORRC_MARKER = '## TorGhost Configuration'
IPV6_BACKUP_FILE = '/etc/tor/torghost-ipv6-backup'
RESOLVED_STOP_MARKER = '/run/torghost-stopped-systemd-resolved'
DOCKER_STOP_MARKER = '/run/torghost-stopped-docker'   # <-- new: marker for docker stop

# Use the module-level marker constant (do not reference a local variable that
# does not exist at module import time).
TORCONTENT = f"""
{TORRC_MARKER}
nickname TorGhostNode
VirtualAddrNetwork 10.0.0.0/10
AutomapHostsOnResolve 1
TransPort 9040
DNSPort 5353
ControlPort 9051
"""

def is_docker_active():
    """
    Return True if systemd reports the docker service is active.
    Non-fatal: returns False on error.
    """
    try:
        res = subprocess.run(['systemctl', 'is-active', 'docker'], capture_output=True, text=True)
        return res.stdout.strip() == 'active'
    except Exception:
        return False

def stop_docker_and_wait(timeout=10):
    """
    Stop the docker service and wait until it is inactive.
    If docker was active and we stopped it, create DOCKER_STOP_MARKER so we can restore later.
    Best-effort: after stopping Docker, back up nat table and remove PREROUTING ADDRTYPE->DOCKER rule
    if present to avoid local NAT loops that affect Tor.
    """
    try:
        if not shutil.which('systemctl'):
            info("systemctl not available; cannot manage Docker here.")
            return
        if not is_docker_active():
            info("Docker not active; skipping stop.")
            return
        info("Stopping Docker to avoid Docker/ADDRTYPE NAT interference...")
        subprocess.run(['systemctl', 'stop', 'docker'], check=False)
        deadline = time.time() + timeout
        while time.time() < deadline:
            if not is_docker_active():
                try:
                    with open(DOCKER_STOP_MARKER, 'w') as f:
                        f.write('stopped\n')
                except Exception:
                    # non-fatal
                    pass
                success("Docker stopped (marker written).")
                # --- best-effort: remove PREROUTING ADDRTYPE -> DOCKER if present ---
                try:
                    # Check for offending PREROUTING rule
                    p = subprocess.run(['bash', '-c', "iptables -t nat -S | grep -E \"-A PREROUTING .*ADDRTYPE|PREROUTING .*DOCKER\" || true"],
                                       capture_output=True, text=True)
                    if p.stdout.strip():
                        ts = int(time.time())
                        backup = f"/run/torghost-nat-backup-{ts}.rules"
                        try:
                            subprocess.run(['bash', '-c', f'iptables-save -t nat > {backup}'], check=False)
                            info(f"Backed up nat table to {backup} before modifications.")
                        except Exception:
                            warn("Could not write nat backup; proceeding cautiously.")
                        # Try to delete the specific PREROUTING ADDRTYPE -> DOCKER rule
                        del_cmd = ['bash', '-c', 'iptables -t nat -D PREROUTING -m addrtype --dst-type LOCAL -j DOCKER']
                        r = subprocess.run(del_cmd, capture_output=True, text=True)
                        if r.returncode == 0:
                            success("Removed PREROUTING ADDRTYPE -> DOCKER rule (best-effort).")
                        else:
                            # not fatal — inform operator
                            warn("Could not remove PREROUTING ADDRTYPE->DOCKER rule automatically (it may have changed). Please remove it manually if present.")
                except Exception as e:
                    warn(f"Error while attempting to remove PREROUTING DOCKER rule: {e}")
                # end best-effort cleanup
                return
            time.sleep(0.5)
        warn("Timed out waiting for Docker to stop.")
    except Exception as e:
        warn(f"Failed to stop Docker: {e}")

def restore_docker_if_stopped():
    """
    Start Docker if torghost previously stopped it (marker exists).
    Removes the marker file after attempting to start.
    """
    try:
        if not os.path.exists(DOCKER_STOP_MARKER):
            return
        if not shutil.which('systemctl'):
            warn("systemctl not available; cannot restore Docker automatically.")
            return
        info("Restoring Docker service that was stopped by torghost...")
        subprocess.run(['systemctl', 'start', 'docker'], check=False)
        try:
            os.remove(DOCKER_STOP_MARKER)
        except Exception:
            pass
        success("Requested Docker start (verify with 'systemctl status docker').")
    except Exception as e:
        warn(f"Failed to restore Docker: {e}")

def set_tor_dnsport(port):
    """
    Set DNSPort in torrc to the given port, backing up the original torrc.
    Returns True on success, False otherwise.
    """
    try:
        # Read and backup
        with open(TORRC_PATH, 'r') as f:
            data = f.read()
        with open(TORRC_PATH + '.bak-torghost', 'w') as f:
            f.write(data)
        # Replace existing DNSPort line or append
        if re.search(r'^\s*DNSPort\s+\d+', data, flags=re.M):
            new = re.sub(r'^\s*DNSPort\s+\d+', f'DNSPort {port}', data, flags=re.M)
        else:
            new = data.rstrip() + f"\nDNSPort {port}\n"
        with open(TORRC_PATH, 'w') as f:
            f.write(new)
        success(f"Set Tor DNSPort to {port} in {TORRC_PATH} (backup created).")
        return True
    except Exception as e:
        warn(f"Failed to set DNSPort in torrc: {e}")
        return False

# Update iptables template: use -I for the owner exemption so it takes effect early.
IPTABLESSCRIPT = """
iptables -F
iptables -t nat -F

# Print existing nat OUTPUT rules (diagnostic — preserved in the log)
iptables -t nat -L OUTPUT -n --line-numbers

# Prevent redirecting packets destined to local addresses (ADDRTYPE LOCAL)
# (avoids redirecting traffic intended for localhost / local sockets into Tor)
iptables -t nat -I OUTPUT 1 -m addrtype --dst-type LOCAL -j RETURN || true

# Exempt root (uid 0) from NAT redirection (avoid redirecting critical system traffic)
iptables -t nat -I OUTPUT -m owner --uid-owner 0 -j RETURN

# Don't redirect traffic generated by the tor user (avoid loops)
iptables -t nat -I OUTPUT -m owner --uid-owner {tor_uid} -j RETURN

# Don't redirect traffic destined to Tor's own listeners (avoid sending Tor->Tor)
iptables -t nat -I OUTPUT -p tcp --dport 9050 -j RETURN
iptables -t nat -I OUTPUT -p tcp --dport 9051 -j RETURN
iptables -t nat -I OUTPUT -p tcp --dport 9040 -j RETURN
iptables -t nat -I OUTPUT -p udp --dport 53 -m owner --uid-owner {tor_uid} -j RETURN || true

# Exclude local / private / link-local / multicast destinations from redirection
iptables -t nat -A OUTPUT -d 127.0.0.0/8 -j RETURN
iptables -t nat -A OUTPUT -d 10.0.0.0/8 -j RETURN
iptables -t nat -A OUTPUT -d 172.16.0.0/12 -j RETURN
iptables -t nat -A OUTPUT -d 192.168.0.0/16 -j RETURN
iptables -t nat -A OUTPUT -d 100.64.0.0/10 -j RETURN
iptables -t nat -A OUTPUT -d 169.254.0.0/16 -j RETURN
iptables -t nat -A OUTPUT -d 224.0.0.0/4 -j RETURN

# Redirect DNS (UDP & TCP) to Tor DNSPort — only for non-tor owners
iptables -t nat -A OUTPUT -p udp --dport 53 -m owner ! --uid-owner {tor_uid} -j REDIRECT --to-ports {dns_port}
iptables -t nat -A OUTPUT -p tcp --dport 53 -m owner ! --uid-owner {tor_uid} -j REDIRECT --to-ports {dns_port}

# Redirect outgoing TCP connections to Tor TransPort — only for non-tor owners
iptables -t nat -A OUTPUT -p tcp --syn -m owner ! --uid-owner {tor_uid} -j REDIRECT --to-ports 9040

# Filter rules: allow established and exempted traffic, block the rest
iptables -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT

# Allow local/network management and loopback destinations
iptables -A OUTPUT -d 127.0.0.0/8 -j ACCEPT
iptables -A OUTPUT -d 10.0.0.0/8 -j ACCEPT
iptables -A OUTPUT -d 172.16.0.0/12 -j ACCEPT
iptables -A OUTPUT -d 192.168.0.0/16 -j ACCEPT
iptables -A OUTPUT -d 100.64.0.0/10 -j ACCEPT
iptables -A OUTPUT -d 169.254.0.0/16 -j ACCEPT

# Allow traffic from the tor user
iptables -A OUTPUT -m owner --uid-owner {tor_uid} -j ACCEPT

# Reject everything else (makes sure non-exempt IPv4 traffic must go via Tor)
iptables -A OUTPUT -j REJECT
"""

# New helper: detect existing NAT redirect rules that could conflict / cause loops
def detect_nat_conflicts():
    """
    Inspect nat OUTPUT rules for existing REDIRECT entries.
    If any REDIRECT to port 9040 or to port 53 already exists, warn and return True.
    This avoids silently applying rules that can cause TransPort/NAT loops.
    """
    try:
        res = subprocess.run(['bash', '-c', 'iptables -t nat -L OUTPUT -n --line-numbers'], capture_output=True, text=True)
        out = res.stdout or ''
        # look for REDIRECT lines and target ports
        for line in out.splitlines():
            if 'REDIRECT' in line:
                # crude parse: look for '--to-ports <port>' or 'ports'
                if '--to-ports 9040' in line or '--to-ports 53' in line:
                    warn(f"Detected existing nat REDIRECT that targets Tor ports: {line.strip()}")
                    return True
                # also if any REDIRECT exists it's suspicious
                if 'REDIRECT' in line:
                    warn(f"Detected existing nat REDIRECT rule: {line.strip()}")
                    return True
        return False
    except Exception as e:
        # If inspection fails, be conservative and report conflict to avoid breaking DNS
        warn(f"Could not inspect existing nat OUTPUT rules: {e}")
        return True

def stop_and_wait(service, timeout=10):
    """
    Stop a systemd service and wait until it is not 'active'.
    Returns True if the service is inactive within timeout, False otherwise.
    Non-fatal: logs warnings on failure.
    """
    try:
        # Best-effort stop
        subprocess.run(['systemctl', 'stop', service], check=False)
        deadline = time.time() + timeout
        while time.time() < deadline:
            st = subprocess.run(['systemctl', 'is-active', service], capture_output=True, text=True).stdout.strip()
            if st != 'active':
                return True
            time.sleep(0.5)
        warn(f"Timed out waiting for {service} to stop.")
        return False
    except Exception as e:
        warn(f"Failed to stop/wait for {service}: {e}")
        return False

# --- Cookie helper functions ------------------------------------------------
def choose_cookie_path():
    """
    Choose a sensible control cookie path for this system.
    Prefer /run/tor if that runtime directory exists, otherwise fall back
    to the persistent DataDirectory location under /var/lib/tor.
    """
    if os.path.isdir('/run/tor'):
        return '/run/tor/control.authcookie'
    if os.path.isdir('/var/lib/tor'):
        return '/var/lib/tor/control_auth_cookie'
    # Fallback (best-effort)
    return '/run/tor/control.authcookie'

def create_cookie_parent_dir(cookie_path):
    """
    Ensure the parent directory of cookie_path exists with safe perms.
    Attempts to chown the directory to the 'tor' user if present.
    Non-fatal: logs warnings on failure.
    """
    parent = os.path.dirname(cookie_path)
    try:
        if not os.path.exists(parent):
            info(f"Creating cookie parent dir {parent}")
            os.makedirs(parent, exist_ok=True)
            try:
                # best-effort chown to tor:tor
                uid = int(subprocess.run(['id', '-u', 'tor'], capture_output=True, text=True).stdout.strip())
                gid = int(subprocess.run(['id', '-g', 'tor'], capture_output=True, text=True).stdout.strip())
                os.chown(parent, uid, gid)
            except Exception:
                # ignore if 'tor' user not present or chown fails
                pass
            try:
                os.chmod(parent, 0o700)
            except Exception:
                pass
        else:
            info(f"Cookie parent dir exists: {parent}")
    except Exception as e:
        warn(f"Failed to create/prepare cookie parent directory {parent}: {e}")

def ensure_cookie_auth_in_torrc():
    """
    Ensure torrc contains CookieAuthentication and a usable CookieAuthFile.
    Removes any existing CookieAuthentication/CookieAuthFile lines (including
    commented variants) then appends a clean block. Returns the chosen cookie
    path on success or None on failure.
    """
    try:
        with open(TORRC_PATH, 'r') as f:
            data = f.read()
    except Exception as e:
        warn(f"Could not read {TORRC_PATH}: {e}")
        return None

    cookie_path = choose_cookie_path()

    # Strip any existing CookieAuthentication/CookieAuthFile lines (even commented)
    lines = []
    for line in data.splitlines():
        if re.match(r'^\s*#?\s*CookieAuthentication\b', line):
            continue
        if re.match(r'^\s*#?\s*CookieAuthFile\b', line):
            continue
        lines.append(line)
    clean = "\n".join(lines).rstrip() + "\n\n"

    # Append a clear block
    block = (
        "# TorGhost: enable cookie auth\n"
        "CookieAuthentication 1\n"
        f"CookieAuthFile {cookie_path}\n"
    )

    new_data = clean + block

    # If identical, return chosen path
    if new_data == data:
        return cookie_path

    # Backup and write
    try:
        backup = TORRC_PATH + f'.bak-torghost-{int(time.time())}'
        shutil.copy(TORRC_PATH, backup)
        with open(TORRC_PATH, 'w') as f:
            f.write(new_data)
        success(f"Updated {TORRC_PATH} to enable CookieAuthentication (backup: {backup}).")
        return cookie_path
    except Exception as e:
        warn(f"Failed to update {TORRC_PATH}: {e}")
        return None

def get_cookie_candidates():
    """
    Return an ordered list of paths to check for Tor control auth cookie.
    Prefer an explicit CookieAuthFile in torrc, then common runtime paths.
    """
    candidates = []
    # If torrc contains CookieAuthFile, prefer that
    try:
        with open(TORRC_PATH, 'r') as f:
            for line in f:
                m = re.match(r'^\s*CookieAuthFile\s+(.+)$', line)
                if m:
                    path = m.group(1).strip().strip('"').strip("'")
                    candidates.append(path)
                    break
    except Exception:
        pass

    # Common locations
    common = [
        '/run/tor/control.authcookie',
        '/run/tor/control_auth_cookie',
        '/var/run/tor/control.authcookie',
        '/var/lib/tor/control_auth_cookie',
        '/var/lib/tor/control.authcookie'
    ]
    for p in common:
        if p not in candidates:
            candidates.append(p)
    return candidates

def wait_for_cookie(candidates=None, timeout=60):
    """
    Wait for any auth cookie in `candidates` to appear.
    Returns the path found or None on timeout. Ensures restrictive perms where possible.
    """
    if candidates is None:
        candidates = get_cookie_candidates()
    deadline = time.time() + timeout
    while time.time() < deadline:
        for path in candidates:
            try:
                if os.path.exists(path):
                    # best-effort secure perms
                    try:
                        os.chown(path, 0, 0)
                    except Exception:
                        pass
                    try:
                        os.chmod(path, 0o600)
                    except Exception:
                        pass
                    info(f"Found Tor control auth cookie: {path}")
                    return path
            except Exception:
                pass
        time.sleep(1)
    warn(f"Timeout waiting for Tor control auth cookie. Checked: {', '.join(candidates)}")
    return None

# --- Core operational functions ----------------------------------------------
def start_torghost():
    """
    Start TorGhost by:
    1. Appending a Tor configuration block (torrc) if not already present.
    2. Backing up and modifying /etc/resolv.conf to point DNS to localhost.
    3. Starting the Tor systemd service.
    4. Determining the 'tor' user UID for firewall exemptions.
    5. Applying iptables and ip6tables rules to route DNS and TCP traffic
       through Tor while excluding local/private networks and the tor user.
    """

    # --- torrc configuration ------------------------------------------------
    # We write a small configuration block to ensure Tor listens on the
    # ports we expect (TransPort 9040, DNSPort 53, ControlPort 9051) and
    # that VirtualAddrNetwork/AutomapHostsOnResolve are enabled.
    torrc_path = '/etc/tor/torrc'
    torrc_marker = '## TorGhost Configuration'
    torrc_content = TORCONTENT

    info("Appending Tor configuration to /etc/tor/torrc (if missing)...")
    try:
        # Read existing torrc and append the marker block only if it's missing
        with open(torrc_path, 'r') as f:
            existing = f.read()

        if torrc_marker not in existing:
            with open(torrc_path, 'a') as f:
                f.write(torrc_content)
            success("Tor configuration appended to /etc/tor/torrc.")
        else:
            info("Tor configuration marker already present; skipping append.")
    # ensure cookie auth lines are present (idempotent) and get chosen cookie path
        cookie_path = ensure_cookie_auth_in_torrc()
        if not cookie_path:
            error("Failed to ensure CookieAuthentication in torrc; aborting.", fatal=True)
    except IOError as e:
        error(f"Error modifying torrc: {e}", fatal=True)

    # Prepare the cookie parent dir (best-effort) so Tor can write the cookie
    create_cookie_parent_dir(cookie_path)
    # Stop systemd-resolved early so Tor can bind DNS ports reliably (record action)
    try:
        # Attempt to stop and wait a short time; only write marker if we actually stopped it.
        if stop_and_wait('systemd-resolved', timeout=6):
            info("systemd-resolved stopped so Tor can bind DNSPort.")
            try:
                with open(RESOLVED_STOP_MARKER, 'w') as f:
                    f.write('stopped\n')
            except Exception:
                # marker write failure is non-fatal
                pass
        else:
            warn("Could not stop systemd-resolved before starting Tor (it may still be active). Proceeding, but DNSPort binding may fail.")
    except Exception as e:
        warn(f"Could not check/stop systemd-resolved: {e}")

    # NEW: stop Docker if present to avoid DOCKER PREROUTING/ADDRTYPE interference
    try:
        stop_docker_and_wait(timeout=8)
    except Exception as e:
        warn(f"Could not stop Docker (non-fatal): {e}")

    # --- Start Tor service and wait for it to be ready --------------------
    info("Starting tor service (systemctl start tor)...")
    try:
        subprocess.run(['systemctl', 'start', 'tor'], check=True,
                       stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        success("Tor service start requested.")
    except subprocess.CalledProcessError:
        error("Failed to start Tor service.", fatal=True)

    # Wait for Tor control port to be available
    info("Waiting for Tor control port (127.0.0.1:9051) to become available (timeout 60s)...")
    if not wait_for_port('127.0.0.1', 9051, timeout=60):
        error("Tor control port 9051 did not become available in time. Aborting.", fatal=True)
    success("Tor control port is reachable.")

    # Wait for cookie to exist before attempting to authenticate / bootstrap.
    # Use multiple candidate paths and a longer timeout to accommodate slow boots.
    cookie_path = wait_for_cookie(get_cookie_candidates(), timeout=60)
    if not cookie_path:
        error(
            "Tor control auth cookie not found after waiting. Aborting start to avoid breaking system DNS.\n"
            "Ensure CookieAuthentication 1 is enabled in /etc/tor/torrc and that Tor can create the cookie\n"
            "(or configure HashedControlPassword and update the script to authenticate using a password).",
            fatal=True
        )

    # proceed to bootstrap check (authenticate will now succeed using the cookie)
    if not wait_for_bootstrap(timeout=120):
        error("Tor did not finish bootstrapping. Aborting to avoid leaving the system without working DNS/routes.", fatal=True)

    # Wait for TransPort (9040) to be listening (required for transparent proxying)
    info("Waiting for Tor TransPort (127.0.0.1:9040) to become available (timeout 30s)...")
    if not wait_for_port('127.0.0.1', 9040, timeout=30):
        warn("Tor TransPort 9040 did not appear to be listening yet. Transparent proxying may fail.")
    else:
        success("Tor TransPort is reachable.")

    # Disable IPv6 system-wide
    disable_ipv6()

    # --- DNS configuration / backup (moved until Tor is up) ----------------
    # Define resolv paths used for backup/restore and replacement.
    resolv = '/etc/resolv.conf'
    resolv_backup = '/etc/resolv.conf.bak-torghost'
    resolv_backup_link = '/etc/resolv.conf.bak-torghost-link'

    # Before changing resolv.conf, ensure systemd-resolved won't intercept DNS.
    # If systemd-resolved is active, stop it temporarily and record that action.
    try:
        resolved_active = subprocess.run(['systemctl', 'is-active', 'systemd-resolved'],
                                         capture_output=True, text=True).stdout.strip() == 'active'
        if resolved_active:
            info("systemd-resolved is active — stopping it so Tor can bind DNSPort...")
            subprocess.run(['systemctl', 'stop', 'systemd-resolved'], check=False)
            try:
                # record that we stopped it so stop_torghost can restart it
                with open(RESOLVED_STOP_MARKER, 'w') as f:
                    f.write('stopped\n')
            except Exception:
                # marker write failure is non-fatal
                pass
    except Exception as e:
        warn(f"Could not check/stop systemd-resolved: {e}")

    # default DNS port Tor will use (prefer 5353 to avoid systemd-resolved conflicts)
    dns_port = 5353

    info(f"Waiting for Tor DNSPort (127.0.0.1:{dns_port}) to be available (timeout 15s)...")
    if not wait_for_port('127.0.0.1', dns_port, timeout=15):
        warn(f"Tor DNSPort {dns_port} not reachable. Attempting fallback to DNSPort 53...")
        # Attempt to reconfigure tor to use 53
        if set_tor_dnsport(53):
            try:
                subprocess.run(['systemctl', 'restart', 'tor'], check=False)
            except Exception:
                pass
            # Wait for control and bootstrap again after restart
            if not wait_for_port('127.0.0.1', 9051, timeout=30):
                error("Tor control port did not come back after restart. Aborting.", fatal=True)
            if not wait_for_bootstrap(timeout=60):
                error("Tor did not finish bootstrapping after restart. Aborting.", fatal=True)
            # now check for DNSPort 53
            if wait_for_port('127.0.0.1', 53, timeout=15):
                dns_port = 53
                success("Tor DNSPort 53 is reachable; using fallback DNS port.")
            else:
                error("Tor DNSPort not listening after fallback restart — aborting start to avoid breaking DNS.", fatal=True)
        else:
            error("Could not update torrc for fallback DNSPort — aborting.", fatal=True)

    # Before modifying /etc/resolv.conf ensure systemd-resolved is actually inactive.
    try:
        st = subprocess.run(['systemctl', 'is-active', 'systemd-resolved'], capture_output=True, text=True).stdout.strip()
        if st == 'active':
            info("systemd-resolved still active - attempting to stop it now before modifying /etc/resolv.conf...")
            if not stop_and_wait('systemd-resolved', timeout=8):
                error("systemd-resolved could not be stopped. Aborting to avoid overwriting system resolver. Manually stop/disable systemd-resolved and retry.", fatal=True)
            else:
                # record that we stopped it
                try:
                    with open(RESOLVED_STOP_MARKER, 'w') as f:
                        f.write('stopped\n')
                except Exception:
                    pass
        else:
            info("systemd-resolved is inactive (or not installed); safe to update /etc/resolv.conf.")
    except Exception as e:
        warn(f"Failed to verify systemd-resolved state: {e}")
        # Be conservative: abort to avoid clobbering resolv.conf
        error("Unable to verify systemd-resolved state; aborting to avoid breaking system DNS.", fatal=True)

    # Additional sanity: ensure /etc/resolv.conf is NOT still the systemd stub or pointing at 127.0.0.53.
    try:
        resolv = '/etc/resolv.conf'
        # If symlink to systemd stub or contains 127.0.0.53, refuse to overwrite and instruct user.
        is_stub = False
        if os.path.islink(resolv):
            target = os.readlink(resolv)
            if 'systemd' in target or 'resolved' in target or 'stub' in target:
                is_stub = True
        else:
            try:
                with open(resolv, 'r') as rf:
                    txt = rf.read()
                    if '127.0.0.53' in txt:
                        is_stub = True
            except Exception:
                # ignore read failures here
                pass
        if is_stub:
            error(
                "/etc/resolv.conf appears to be the systemd-resolved stub (nameserver 127.0.0.53) or symlinked to the resolver.\n"
                "TorGhost will not overwrite the system resolver while systemd-resolved is active. Please ensure systemd-resolved is stopped/disabled and /etc/resolv.conf is writable, then retry.\n"
                "Example remediation:\n"
                "  sudo systemctl stop systemd-resolved\n"
                "  sudo systemctl disable --now systemd-resolved\n"
                "  sudo rm /etc/resolv.conf  # if it's a symlink to the stub (be careful!)\n"
                "Then re-run: sudo torghost start",
                fatal=True
            )
    except Exception as e:
        # non-fatal but inform
        warn(f"Failed to sanity-check /etc/resolv.conf: {e}")

    info("Preparing DNS configuration (resolv.conf) — backing up and pointing to Tor DNSPort...")
    try:
        # Now that DNSPort is confirmed and systemd-resolved stopped, safely replace resolv.conf.
        if os.path.islink(resolv):
            orig_target = os.readlink(resolv)
            info(f"/etc/resolv.conf is a symlink to {orig_target}; recording and replacing with a plain file.")
            with open(resolv_backup_link, 'w') as f:
                f.write(orig_target)
            os.remove(resolv)
        else:
            if not os.path.exists(resolv_backup):
                shutil.copy(resolv, resolv_backup)
                info(f"Backed up /etc/resolv.conf to {resolv_backup}")
            else:
                info("Existing resolv.conf backup found; will not overwrite.")

        # Write a plain resolv.conf pointing to the local Tor DNSPort (127.0.0.1)
        with open(resolv, 'w') as f:
            f.write("nameserver 127.0.0.1\n")
        success("Wrote /etc/resolv.conf -> nameserver 127.0.0.1")
    except IOError as e:
        error(f"Error configuring DNS: {e}", fatal=True)

    # --- Determine Tor user's UID -----------------------------------------
    info("Determining 'tor' user UID for firewall exemptions...")
    try:
        tor_uid = subprocess.run(['id', '-u', 'tor'],
                                 capture_output=True, text=True, check=True).stdout.strip()
        info(f"Using tor UID: {tor_uid}")
    except subprocess.CalledProcessError:
        error("Failed to get Tor UID.", fatal=True)

    # Apply IPv6 blocking rules immediately after we know tor_uid
    try:
        apply_ipv6_block(tor_uid)
    except Exception as e:
        warn(f"IPv6 block application failed: {e}")

    # --- Prepare iptables (IPv4) script -----------------------------------
    # Build the iptables script as a heredoc string and then execute in bash.
    # Updated to:
    # - Exclude full RFC1918 ranges (10/8, 172.16/12, 192.168/16), carrier-grade NAT (100.64/10),
    #   link-local (169.254/16) and multicast (224/4) from redirection.
    # - Exempt the tor user's traffic to avoid loops.
    # - Redirect UDP/TCP port 53 (DNS) to Tor DNSPort and redirect TCP SYN to TransPort.
    # - In filter table accept established/related, tor user, and local networks, then REJECT all else.
    iptables_script = IPTABLESSCRIPT.format(tor_uid=tor_uid, dns_port=dns_port)

    # --- Apply iptables rules ---------------------------------------------
    info("Applying IPv4 iptables rules to route traffic through Tor...")

    # Safety check: abort if there are existing nat REDIRECT rules that may cause loops.
    if detect_nat_conflicts():
        error("Existing NAT/REDIRECT rules detected that may conflict with TorGhost. Aborting to avoid creating a TransPort/NAT loop. Inspect `iptables -t nat -L OUTPUT -n --line-numbers` and remove conflicting rules before retrying.", fatal=True)

    # New check: detect PREROUTING ADDRTYPE/DOCKER entries that can still intercept local destinations.
    if detect_prerouting_addrtype_docker():
        error("Please remove or restrict the nat PREROUTING ADDRTYPE/DOCKER rule (it matches local destinations) before running torghost. Example remediation:\n"
              "  sudo iptables -t nat -D PREROUTING -m addrtype --dst-type LOCAL -j DOCKER\n"
              "or re-add restricted:\n"
              "  sudo iptables -t nat -I PREROUTING 1 ! -d 127.0.0.0/8 -m addrtype --dst-type LOCAL -j DOCKER", fatal=True)

    try:
        subprocess.run(['bash', '-c', iptables_script], check=True,
                       stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        success("IPv4 iptables rules applied.")
    except subprocess.CalledProcessError:
        error("Failed to apply IPv4 iptables rules.", fatal=True)

    # Install additional DNS hardening rules (defense-in-depth)
    try:
        tighten_dns_rules(tor_uid)
    except Exception as e:
        warn(f"Could not apply DNS hardening rules: {e}")

    # --- Final status messages --------------------------------------------
    success(f"TorGhost started. Current IP: {get_ip()}")
    info("Note: All DNS (IPv4 & IPv6) and TCP traffic routed through Tor.")
    info("Run 'sudo torghost stop' to revert all changes.")

def stop_torghost(monitor=False, interval=10):
    """
    Revert changes made by start_torghost.
    If monitor=True: after stopping services and flushing IPv4 rules, enter an
    interactive monitoring loop showing iptables / nat / ip6tables / resolv.conf
    until the user types 'q' or presses Ctrl-C, then continue with cleanup.
    """
    # --- Flush IPv4 iptables ----------------------------------------------
    info("Flushing IPv4 iptables and restoring default ACCEPT policies...")
    try:
        subprocess.run(['bash', '-c', """
        iptables -P INPUT ACCEPT
        iptables -P FORWARD ACCEPT
        iptables -P OUTPUT ACCEPT
        iptables -t nat -F
        iptables -t mangle -F
        iptables -F
        iptables -X
        """], check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        success("IPv4 firewall flushed.")
    except subprocess.CalledProcessError:
        warn("Failed to flush IPv4 iptables; manual intervention may be required.")

    # --- Stop Tor service -------------------------------------------------
    info("Stopping Tor service (systemctl stop tor)...")
    try:
        subprocess.run(['systemctl', 'stop', 'tor'], check=True,
                       stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        success("Tor service stopped.")
    except subprocess.CalledProcessError:
        warn("Failed to stop Tor service; it may already be stopped or not installed.")

    # If monitor mode requested, present interactive view before final cleanup
    if monitor:
        info("Entering interactive stop-monitor mode. Type 'q' + Enter to proceed with cleanup, or Ctrl-C to abort.")
        stop_event = threading.Event()

        def input_watcher():
            try:
                while not stop_event.is_set():
                    line = sys.stdin.readline()
                    if not line:
                        time.sleep(0.1)
                        continue
                    if line.strip().lower() == 'q':
                        stop_event.set()
                        break
            except Exception:
                stop_event.set()

        watcher = threading.Thread(target=input_watcher, daemon=True)
        watcher.start()

        try:
            while not stop_event.is_set():
                # Print brief status snapshots for debugging/inspection
                print("\n--- nat OUTPUT (iptables -t nat -L OUTPUT -v -n) ---")
                try:
                    nat = subprocess.run(['bash', '-c', 'iptables -t nat -L OUTPUT -v -n'], capture_output=True, text=True)
                    print(nat.stdout)
                except Exception as e:
                    print(f"(failed to read nat OUTPUT: {e})")

                print("\n--- filter OUTPUT (iptables -L OUTPUT -v -n) ---")
                try:
                    filt = subprocess.run(['bash', '-c', 'iptables -L OUTPUT -v -n'], capture_output=True, text=True)
                    print(filt.stdout)
                except Exception as e:
                    print(f"(failed to read filter OUTPUT: {e})")

                print("\n--- ip6tables OUTPUT (ip6tables -L OUTPUT -v -n) ---")
                try:
                    ip6 = subprocess.run(['bash', '-c', 'ip6tables -L OUTPUT -v -n'], capture_output=True, text=True)
                    print(ip6.stdout)
                except Exception as e:
                    print(f"(failed to read ip6tables OUTPUT: {e})")

                print("\n--- /etc/resolv.conf (current) ---")
                try:
                    with open('/etc/resolv.conf', 'r') as rf:
                        print(rf.read().strip())
                except Exception as e:
                    print(f"(failed to read /etc/resolv.conf: {e})")

                info(f"Monitoring... next update in {interval}s. Press 'q' then Enter to continue with cleanup.")
                for _ in range(int(interval)):
                    if stop_event.is_set():
                        break
                    time.sleep(1)
        except KeyboardInterrupt:
            info("Interrupted by user (Ctrl-C) during monitor; proceeding with cleanup.")
            stop_event.set()

        stop_event.set()
        watcher.join(timeout=1)
        info("Exiting monitor and continuing cleanup.")

    # --- Clean up torrc ---------------------------------------------------
    # Ensure torrc path/marker are defined (use module constants)
    torrc_path = TORRC_PATH
    torrc_marker = TORRC_MARKER

    info("Cleaning up tor configuration in /etc/tor/torrc...")
    try:
        with open(torrc_path, 'r') as f:
            lines = f.readlines()

        in_block = False
        cleaned_lines = []
        for line in lines:
            if torrc_marker in line:
                in_block = True
                continue
            if in_block and line.strip() == '':
                in_block = False
                continue
            if not in_block:
                cleaned_lines.append(line)

        with open(torrc_path, 'w') as f:
            f.writelines(cleaned_lines)
        success("Removed TorGhost configuration block from torrc.")
    except IOError as e:
        warn(f"Failed to clean torrc: {e}")

    # --- Restore network resolver ----------------------------------------
    # Define resolv paths used for backup/restore and restoration steps.
    resolv = '/etc/resolv.conf'
    resolv_backup = '/etc/resolv.conf.bak-torghost'
    resolv_backup_link = '/etc/resolv.conf.bak-torghost-link'

    info("Restoring original /etc/resolv.conf (or symlink) if backup exists...")
    if os.path.exists(resolv_backup_link):
        try:
            with open(resolv_backup_link, 'r') as f:
                orig_target = f.read().strip()
            if os.path.exists(resolv):
                try:
                    os.remove(resolv)
                except Exception:
                    pass
            os.symlink(orig_target, resolv)
            os.remove(resolv_backup_link)
            success("Restored original resolv.conf symlink.")
        except IOError as e:
            warn(f"Failed to restore symlinked resolv.conf: {e}")
    elif os.path.exists(resolv_backup):
        try:
            shutil.move(resolv_backup, resolv)
            success("Restored backup /etc/resolv.conf.")
        except IOError as e:
            warn(f"Failed to restore resolv.conf: {e}")
    else:
        warn("No resolv.conf backup found. DNS may need manual restoration.")

    # --- Remove IPv6 blocking rules and restore default IPv6 policies -----
    info("Removing IPv6 blocking rules and restoring policies...")
    try:
        # flush ip6tables and set OUTPUT policy to ACCEPT to restore connectivity
        subprocess.run(['bash', '-c', 'ip6tables -F || true'], check=False)
        subprocess.run(['bash', '-c', 'ip6tables -t raw -F || true'], check=False)
        subprocess.run(['bash', '-c', 'ip6tables -P OUTPUT ACCEPT || true'], check=False)
        success("IPv6 ip6tables rules cleared and OUTPUT policy set to ACCEPT.")
    except Exception as e:
        warn(f"Failed to clear ip6tables rules: {e}")

    # --- Restore IPv6 sysctl settings (if changed) ------------------------
    try:
        restore_ipv6()
    except Exception as e:
        warn(f"IPv6 restore step failed: {e}")

    # --- Restore Docker if torghost stopped it earlier --------------------
    try:
        restore_docker_if_stopped()
    except Exception as e:
        warn(f"Failed to restore Docker automatically: {e}")

    # --- Final status messages --------------------------------------------
    success(f"TorGhost stopped. Current IP: {get_ip()}")

def switch_tor():
    """
    Ask the Tor control port for a new circuit (NEWNYM), effectively switching
    the exit node and changing the apparent public IP. Wait a short time for
    the circuit to be established and then report the new IP.
    """
    try:
        with Controller.from_port(port=9051) as controller:
            try:
                controller.authenticate()
            except Exception as e:
                error("Failed to authenticate to Tor control port. Ensure CookieAuthentication or HashedControlPassword is configured and the script has access to the control auth cookie.", fatal=False)
                return
            controller.signal(Signal.NEWNYM)
    except Exception as e:
        error(f"Failed to connect to Tor control port: {e}", fatal=False)
        return

    # Allow time for the new circuit to be used
    time.sleep(5)
    print(f"{t()} CURRENT IP: {bcolors.GREEN}{get_ip()}{bcolors.ENDC}")


def show_status():
    """
    Show basic status: whether the tor service is active and the current IP.
    This is a non-root operation (only reads state).
    """
    ip = get_ip()
    tor_status = subprocess.run(['systemctl', 'is-active', 'tor'],
                                capture_output=True, text=True).stdout.strip()
    print(f"Tor Status: {tor_status}")
    print(f"Current IP: {ip}")


def tighten_dns_rules(tor_uid):
    """
    Add extra filter rules to prevent any non-tor user from sending DNS (UDP/TCP 53)
    directly to the network. These are defense-in-depth: the nat redirect should
    catch DNS, but this prevents escapes (and helps detect misbehavior).
    """
    info("Installing additional DNS hardening rules (filter table)...")
    try:
        # UDP 53: reject packets from processes not running as tor (IPv4)
        subprocess.run(['bash', '-c',
            f'iptables -C OUTPUT -p udp --dport 53 -m owner ! --uid-owner {tor_uid} -j REJECT >/dev/null 2>&1 || '
            f'iptables -I OUTPUT 1 -p udp --dport 53 -m owner ! --uid-owner {tor_uid} -j REJECT'
        ], check=False)
        # TCP 53: same for TCP DNS (IPv4)
        subprocess.run(['bash', '-c',
            f'iptables -C OUTPUT -p tcp --dport 53 -m owner ! --uid-owner {tor_uid} -j REJECT >/dev/null 2>&1 || '
            f'iptables -I OUTPUT 1 -p tcp --dport 53 -m owner ! --uid-owner {tor_uid} -j REJECT'
        ], check=False)

        # IPv6 DNS hardening: reject non-tor user IPv6 DNS (UDP & TCP 53)
        subprocess.run(['bash', '-c',
            f'ip6tables -C OUTPUT -p udp --dport 53 -m owner ! --uid-owner {tor_uid} -j REJECT >/dev/null 2>&1 || '
            f'ip6tables -I OUTPUT 1 -p udp --dport 53 -m owner ! --uid-owner {tor_uid} -j REJECT'
        ], check=False)
        subprocess.run(['bash', '-c',
            f'ip6tables -C OUTPUT -p tcp --dport 53 -m owner ! --uid-owner {tor_uid} -j REJECT >/dev/null 2>&1 || '
            f'ip6tables -I OUTPUT 1 -p tcp --dport 53 -m owner ! --uid-owner {tor_uid} -j REJECT'
        ], check=False)

        success("DNS hardening rules installed (IPv4 & IPv6).")
    except Exception as e:
        warn(f"Failed to install DNS hardening rules: {e}")

# New: apply strict IPv6 block (allow loopback/local/tor user only)
def apply_ipv6_block(tor_uid):
    """
    Install ip6tables rules to block all outbound IPv6 traffic except:
    - loopback (::1)
    - link-local fe80::/10
    - unique-local fc00::/7
    - multicast ff00::/8
    - traffic from the tor user (avoid loops)
    """
    info("Applying strict IPv6 outbound block (ip6tables)...")
    try:
        # flush and set default DROP for OUTPUT, but allow critical exceptions
        commands = [
            "ip6tables -F",
            "ip6tables -t raw -F || true",
            "ip6tables -P OUTPUT DROP",
            "ip6tables -A OUTPUT -o lo -j ACCEPT",
            f"ip6tables -A OUTPUT -m owner --uid-owner {tor_uid} -j ACCEPT",
            "ip6tables -A OUTPUT -d ::1/128 -j ACCEPT",
            "ip6tables -A OUTPUT -d fe80::/10 -j ACCEPT",
            "ip6tables -A OUTPUT -d fc00::/7 -j ACCEPT",
            "ip6tables -A OUTPUT -d ff00::/8 -j ACCEPT",
            # allow neighbor discovery to link-local if needed
            "ip6tables -A OUTPUT -p icmpv6 -j ACCEPT"
        ]
        for cmd in commands:
            subprocess.run(['bash', '-c', cmd], check=False, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        success("IPv6 blocking rules applied.")
    except Exception as e:
        warn(f"Failed to apply IPv6 block rules: {e}")

def diagnose_dns():
    """
    Collect diagnostic information for Tor and DNS listener issues.
    Intended to be run as root (sudo) so it can read journal and socket info.
    """
    info("Starting diagnostic dump for Tor / DNS issues...")

    def run(cmd):
        try:
            p = subprocess.run(cmd, capture_output=True, text=True)
            out = p.stdout.strip()
            if p.stderr:
                out += ("\n" + p.stderr.strip())
            return p.returncode, out
        except Exception as e:
            return 1, f"Exception running {' '.join(cmd)}: {e}"

    # 1) show listening UDP/TCP sockets
    print("\n--- Listening UDP sockets (ss -ulpn) ---")
    _, out = run(['ss', '-ulpn'])
    print(out)

    print("\n--- Listening TCP sockets (ss -ltnp) ---")
    _, out = run(['ss', '-ltnp'])
    print(out)

    # 2) check specific ports of interest
    for port in ('53', '5353', '9040', '9050', '9051'):
        print(f"\n--- ss listener check for 127.0.0.1:{port} ---")
        _, out = run(['ss', '-ulpn', f'src', f'127.0.0.1:{port}'])
        print(out)

    # 3) tor service status + recent logs
    print("\n--- systemctl status tor (short) ---")
    _, out = run(['systemctl', 'status', 'tor', '--no-pager'])
    print(out)

    print("\n--- journalctl -u tor (last 200 lines) ---")
    _, out = run(['journalctl', '-u', 'tor', '-n', '200', '--no-pager'])
    print(out)

    # 4) show /etc/tor/torrc snippet (if readable)
    print("\n--- /etc/tor/torrc (first 200 lines) ---")
    try:
        with open(TORRC_PATH, 'r') as f:
            for i, line in enumerate(f):
                if i >= 200:
                    break
                print(line.rstrip())
    except Exception as e:
        print(f"Could not read {TORRC_PATH}: {e}")

    # 5) show backup torrc if present
    bak = TORRC_PATH + '.bak-torghost'
    if os.path.exists(bak):
        print(f"\n--- {bak} (first 200 lines) ---")
        try:
            with open(bak, 'r') as f:
                for i, line in enumerate(f):
                    if i >= 200:
                        break
                    print(line.rstrip())
        except Exception as e:
            print(f"Could not read {bak}: {e}")

    # 6) try DNS queries against 127.0.0.1:53 and 127.0.0.1:5353 using dig (if available)
    dig = shutil.which('dig')
    if dig:
        for p in (53, 5353):
            print(f"\n--- dig test against 127.0.0.1:{p} for example.com ---")
            rc, out = run([dig, f'@127.0.0.1', '-p', str(p), 'example.com', '+short', '+time=2'])
            if out.strip():
                print(out.strip())
            else:
                print("(no response or timed out)")
    else:
        print("\n'dig' not found on system; skipping active DNS queries. Install bind/dnsutils for active testing.")

    # 7) try to query Tor control for listener info and bootstrap-phase if auth works
    try:
        with Controller.from_port(port=9051) as controller:
            try:
                controller.authenticate()
                print("\nAuthenticated to Tor control port.")
            except Exception as e:
                print(f"\nCould not authenticate to Tor control port: {e}")
                controller = None

            if controller:
                try:
                    val = controller.get_info("status/bootstrap-phase")
                    print(f"\nstatus/bootstrap-phase: {val}")
                except Exception as e:
                    print(f"\nCould not get bootstrap info: {e}")
                # Try several listener-related keys
                for key in ("net/listeners/socks", "net/listeners/control", "net/listeners/dir", "net/listeners/or"):
                    try:
                        v = controller.get_info(key)
                        print(f"\nGETINFO {key}: {v}")
                    except Exception:
                        pass
    except Exception as e:
        print(f"\nCould not open Tor control port connection: {e}")

    # 8) show resolv.conf
    print("\n--- /etc/resolv.conf (current) ---")
    try:
        with open('/etc/resolv.conf', 'r') as rf:
            print(rf.read().strip())
    except Exception as e:
        print(f"Could not read /etc/resolv.conf: {e}")

    print("\n--- End of diagnostic dump ---")
    info("Diagnostic dump complete. Review outputs above for missing listeners, tor logs, or permission errors.")


def dns_leak_check(duration=6):
    """
    Quick DNS leak detection:
    - If tcpdump is available, run it for `duration` seconds and look for
      any UDP/53 packets not to/from 127.0.0.1 (IPv4) or ::1 (IPv6).
    - If tcpdump is not available, examine iptables nat OUTPUT counters as a hint.
    Returns True if a leak was observed, False otherwise.
    """
    info("Starting DNS leak check...")
    tcpdump_path = shutil.which('tcpdump')
    if tcpdump_path:
        info(f"Using tcpdump to monitor DNS on all interfaces for {duration} seconds...")
        try:
            # check IPv4 DNS leaks
            cmd_v4 = ['timeout', str(duration), 'tcpdump', '-n', '-i', 'any', 'udp', 'port', '53', 'and', 'not', 'host', '127.0.0.1', '-c', '1']
            proc_v4 = subprocess.run(cmd_v4, capture_output=True, text=True)
            out_v4 = proc_v4.stdout.strip() + proc_v4.stderr.strip()
            if proc_v4.returncode == 0 and out_v4:
                warn("DNS leak detected (IPv4): observed UDP/53 traffic to non-local addresses:")
                print(out_v4)
                return True
            # check IPv6 DNS leaks
            cmd_v6 = ['timeout', str(duration), 'tcpdump', '-n', '-i', 'any', 'ip6', 'and', 'udp', 'port', '53', 'and', 'not', 'host', '::1', '-c', '1']
            proc_v6 = subprocess.run(cmd_v6, capture_output=True, text=True)
            out_v6 = proc_v6.stdout.strip() + proc_v6.stderr.strip()
            if proc_v6.returncode == 0 and out_v6:
                warn("DNS leak detected (IPv6): observed UDP/53 traffic to non-local IPv6 addresses:")
                print(out_v6)
                return True
            success("No non-local DNS packets observed during capture windows.")
            return False
        except Exception as e:
            warn(f"tcpdump monitoring failed: {e}")
            return False
    else:
        info("tcpdump not found. Checking iptables nat OUTPUT counters as a heuristic...")
        try:
            nat = subprocess.run(['bash', '-c', 'iptables -t nat -L OUTPUT -v -n'], capture_output=True, text=True)
            print(nat.stdout)
            info("If nat OUTPUT shows zero hits for the DNS redirect rule, DNS may not be redirected.")
            # also show ip6tables OUTPUT rules as heuristic
            ip6 = subprocess.run(['bash', '-c', 'ip6tables -L OUTPUT -v -n'], capture_output=True, text=True)
            print(ip6.stdout)
            return False
        except Exception as e:
            warn(f"Failed to inspect iptables: {e}")
            return False

# New: continuous monitor mode for leak checking
def monitor_leaks(interval=10):
    """
    Continuously run dns_leak_check() every `interval` seconds.
    User may type 'q' + Enter to quit, or press Ctrl-C.
    """
    info(f"Entering continuous leak-monitor mode (interval {interval}s).")
    info("Press 'q' then Enter to quit, or Ctrl-C to exit.")
    stop_event = threading.Event()

    def input_watcher():
        # Blocking read on stdin in a thread; sets stop_event when 'q' received.
        try:
            while not stop_event.is_set():
                line = sys.stdin.readline()
                if not line:
                    # EOF or no input; small sleep to avoid busy loop
                    time.sleep(0.1)
                    continue
                if line.strip().lower() == 'q':
                    stop_event.set()
                    break
        except Exception:
            stop_event.set()

    watcher = threading.Thread(target=input_watcher, daemon=True)
    watcher.start()

    try:
        while not stop_event.is_set():
            leak = dns_leak_check(duration=6)
            if leak:
                warn("Leak detected during monitoring cycle.")
            else:
                success("No leak detected in this cycle.")
            # wait interval seconds but exit early if stop_event set
            for _ in range(int(interval)):
                if stop_event.is_set():
                    break
                time.sleep(1)
    except KeyboardInterrupt:
        info("Interrupted by user (Ctrl-C). Exiting monitor.")
        stop_event.set()

    # Ensure watcher thread will finish
    stop_event.set()
    watcher.join(timeout=1)
    info("Leak monitor stopped. Returning to shell.")

# New helper: wait for Tor bootstrap to complete
def wait_for_bootstrap(timeout=120, poll_interval=2):
    """
    Connect to Tor's control port and wait until bootstrap progress reaches 100%.
    Returns True if bootstrap completed, False otherwise.
    Attempts to authenticate via available methods; logs warnings if auth fails.
    """
    info("Connecting to Tor control port to monitor bootstrap progress...")
    deadline = time.time() + timeout
    try:
        with Controller.from_port(port=9051) as controller:
            try:
                controller.authenticate()
                info("Authenticated to Tor control port.")
            except Exception as e:
                warn(f"Could not authenticate to Tor control port: {e}. Some control features will be unavailable.")
                # We still attempt to read bootstrap-phase (may fail), so continue

            while time.time() < deadline:
                try:
                    val = controller.get_info("status/bootstrap-phase")
                    # example: 'PROGRESS=80 TAG=... SUMMARY="..."'
                    m = re.search(r'PROGRESS=(\d+)', val)
                    progress = int(m.group(1)) if m else 0
                    info(f"Tor bootstrap progress: {progress}%")
                    if progress >= 100:
                        success("Tor bootstrap reached 100%")
                        return True
                except Exception:
                    # ignore transient read errors and retry
                    pass
                time.sleep(poll_interval)
            warn("Timed out waiting for Tor to finish bootstrapping.")
            return False
    except Exception as e:
        warn(f"Failed to connect to Tor control port for bootstrap check: {e}")
        return False

# --- Main execution flow ----------------------------------------------------
# Install a SIGINT handler to allow graceful exit with Ctrl-C.
signal.signal(signal.SIGINT, sigint_handler)

# Basic CLI parsing. Require a single subcommand.
if len(sys.argv) < 2:
    usage()
    show_status()

command = sys.argv[1].lower()

# For operations that modify system state, ensure running as root.
if command in ['start', 'stop', 'switch']:
    if os.geteuid() != 0:
        print(f"{bcolors.RED}{bcolors.BOLD}You must be root to run this command.{bcolors.ENDC}")
        sys.exit(1)

# Dispatch subcommands to their handlers.
if command == "start":
    logo()
    start_torghost()
elif command == "stop":
    logo()
    # support optional: sudo torghost stop monitor [interval]
    monitor_mode = False
    interval = 10
    if len(sys.argv) >= 3 and sys.argv[2].lower() in ('monitor', 'watch'):
        monitor_mode = True
        if len(sys.argv) >= 4:
            try:
                interval = int(sys.argv[3])
            except Exception:
                warn("Invalid interval; using default 10s.")
    stop_torghost(monitor=monitor_mode, interval=interval)
elif command == "switch":
    logo()
    switch_tor()
elif command == "status":
    logo()
    show_status()
elif command in ("check-leak", "checkleak", "diag", "diagnose"):
    # Continuous leak monitoring mode or diagnostics
    # If user requested 'diag' run diagnostics, otherwise run monitor
    if command in ("diag", "diagnose"):
        logo()
        diagnose_dns()
    else:
        logo()
        interval = 10
        if len(sys.argv) >= 3:
            try:
                interval = int(sys.argv[2])
            except Exception:
                warn("Invalid interval; using default 10s.")
        monitor_leaks(interval=interval)
else:
    usage()

